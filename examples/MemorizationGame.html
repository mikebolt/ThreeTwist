<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" lang="en"/>
    <title>Algorithm Memorization Game</title>
    <link rel="stylesheet" href="../build/styles/cube.css"/>
    <script src="../build/ThreeTwist.js"></script>
    <style>
      .centered {
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }
      
      #cubeContainer {
        width: 450px;
        height: 450px;
      }
      
      #moveDisplay {
        font-family: sans-serif;
        font-weight: bold;
        height: 1em;
        width: 600px;
      }
      
      #prompt {
        width: 800px;
      }
      
      #setupArea {
        width: 600px;
      }
      
      #algorithmTextbox {
        width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="cubeContainer" class="centered">
    </div>
    
    <h1 id="moveDisplay" class="centered">
    </h1><br/>
    
    <h2 id="prompt" class="centered">
    </h2>
    
    <div id="setupArea" class="centered">
      <span>Algorithm to memorize: </span><input id="algorithmTextbox" type="text" value="R U R' U R U2 R'"/><br/>
      <span>Memorization duration: </span><input id="memorizationDurationTextbox" type="text" value="2"/><span> (seconds)</span><br/>
      <span>Between-rounds break duration: </span><input id="breakDurationTextbox" type="text" value="4"/><span> (seconds)</span><br/>
      <!-- TODO: make this a dropdown -->
      <span>Moves per round: </span><input id="movesPerRoundTextbox" type="text" value="1"/>
      <input id="startButton" type="button" value="Start"/>
    </div>
    
    <div id="restartArea" style="display: none" class="centered">
      <input id="restartButton" type="button" value="Restart"/>
    </div>
    <script>
      var cube;
      
      var cubeContainer = document.getElementById('cubeContainer');
      var moveDisplay = document.getElementById('moveDisplay');
      var prompt = document.getElementById('prompt');
      var setupArea = document.getElementById('setupArea');
      var algorithmTextbox = document.getElementById('algorithmTextbox');
      var memorizationDurationTextbox = document.getElementById('memorizationDurationTextbox');
      var breakDurationTextbox = document.getElementById('breakDurationTextbox');
      var movesPerRoundTextbox = document.getElementById('movesPerRoundTextbox');
      var startButton = document.getElementById('startButton');
      var restartArea = document.getElementById('restartArea');
      var restartButton = document.getElementById('restartButton');
      
      var memorizationDuration;
      var breakDuration;
      var defaultTwistDuration = 500;
      var demonstrationTwistDuration;
      var movesPerRound;
      
      startButton.onclick = startGame;
      restartButton.onclick = restart;
      resetCube();
      
      function resetCube() {
        cubeContainer.innerHTML = 'Please wait a second while the cube loads.';
        if (cube !== undefined) {
          cube.destroy();
        }
        cube = new ThreeTwist.Cube();
        clear(cubeContainer);
        cubeContainer.appendChild(cube.domElement);
      }
      
      function enableInteraction() {
        cube.mouseControlsEnabled = true;
        document.addEventListener('keypress', cube.keypressListener);
      }
      
      function disableInteraction() {
        cube.mouseControlsEnabled = false;
        document.removeEventListener('keypress', cube.keypressListener);
      }
      
      function setPrompt(promptText) {
        prompt.innerHTML = promptText;
      }
      
      function clear(element) {
        element.innerHTML = '';
      }
      
      function hide(element) {
        element.style.display = 'none';
      }
      
      function show(element) {
        element.style.display = '';
      }
      
      // Returns a string representing a single twist/move.
      function twistToString(twist) {
        var suffix = '';
        if (twist.degrees === 180) {
          suffix = '2';
        }
        else if (twist.command === twist.command.toLowerCase()) {
          if (twist.degrees === 90) {
            suffix = "'";
          }
        }
        else if (twist.command === twist.command.toUpperCase()) {
          if (twist.degrees === -90) {
            suffix = "'";
          }
        }
        
        return twist.command.toUpperCase() + suffix;
      }
      
      function parseAlgorithm(algorithmString) {
        var algorithm = algorithmString.split(' ');
        moveArray = [];
        for (var i = 0; i < algorithm.length; ++i) {
          var command = algorithm[i].substring(0, 1);
          var angle = 90;
          if (algorithm[i].endsWith("2'") || algorithm[i].endsWith("'2")) {
            angle = -180;
          }
          else if (algorithm[i].endsWith("'")) {
            angle = -90;
          }
          else if (algorithm[i].endsWith('2')) {
            angle = 180;
          }
          var twist = new ThreeTwist.Twist(command, angle);
          if (twist) { // Invalid twists will be false
            moveArray.push(twist);
          }
        }
        
        return moveArray;
      }
      
      // A half turn (as opposed to a quarter turn) is a 180 degree turn.
      function countHalfTurns(algorithm) {
        var halfTurns = 0;
        algorithm.forEach(function(move) {
          if (move.degrees === 180 || move.degrees === -180) {
            ++halfTurns;
          }
        });
        return halfTurns;
      }
      
      function inverseAlgorithm(moveArray) {
        var inversed = [];
        for (var i = moveArray.length - 1; i >= 0; --i) {
          inversed.push(moveArray[i].getInverse());
        }
        return inversed;
      }
      
      function performAlgorithmInstantly(algorithm) {
        var oldDuration = cube.twistDuration;
        cube.twistDuration = 0;
        algorithm.forEach(function(twist) {
          cube.immediateTwist(twist);
        });
        cube.twistDuration = oldDuration;
      }
      
      function startGame() {
        hide(setupArea);
        setPrompt('Get ready to memorize.');
        
        algorithm = parseAlgorithm(algorithmTextbox.value);
        inverse = inverseAlgorithm(algorithm);
        
        memorizationDuration = parseFloat(memorizationDurationTextbox.value, 10) * 1000;
        if (isNaN(memorizationDuration)) {
          memorizationDuration = 2000;
        }
        
        breakDuration = parseFloat(breakDurationTextbox.value, 10) * 1000;
        if (isNaN(breakDuration)) {
          breakDuration = 4000;
        }
        
        movesPerRound = parseInt(movesPerRoundTextbox.value, 10);
        if (isNaN(movesPerRound) || movesPerRound < 1) {
          movesPerRound = 1;
        }
        
        if (movesPerRound > algorithm.length) {
          movesPerRound = algorithm.length;
        }
        
        demonstrationTwistDuration = (3 / 4) * memorizationDuration / movesPerRound;
        
        resetCube();
        disableInteraction();
        
        // Setup the cube by playing the algorithm backwards, twice as fast as normal.
        cube.twistDuration = defaultTwistDuration / 2;
        cube.twist(inverse);
        var numHalfTurns = countHalfTurns(inverse);
        var scrambleWaitTime = 1000 + inverse.length * cube.twistDuration;

        setTimeout(function() {
          startMemorizationPhase(algorithm, inverse, movesPerRound);
        }, scrambleWaitTime);
      }
      
      function startMemorizationPhase(algorithm, inverse, numMoves) {
        var moveIndex = 0;
        resetCube()
        disableInteraction();
        performAlgorithmInstantly(inverse);
        cube.twistDuration = demonstrationTwistDuration;
        
        if (numMoves > algorithm.length) {
          numMoves = algorithm.length;
        }
        
        var showNextMoves = function() {
          if (moveIndex >= numMoves) {
            startTestPhase(algorithm, inverse, numMoves);
          }
          else {
            showMoves(algorithm.slice(moveIndex, moveIndex + movesPerRound));
            moveIndex += movesPerRound;
            setTimeout(showNextMoves, memorizationDuration);
          }
        };
        
        showNextMoves();
      }
      
      function showMoves(moves) {
        var moveText = '';
        for (var i = 0; i < moves.length; ++i) {
          moveText += twistToString(moves[i]);
          if (i !== moves.length - 1) {
            moveText += ' ';
          }
        }
        moveDisplay.innerHTML = moveText;
        cube.twist(moves);
      }
      
      function startTestPhase(algorithm, inverse, numMoves) {
        clear(moveDisplay);
        resetCube();
        performAlgorithmInstantly(inverse);
        cube.twistDuration = defaultTwistDuration;
        enableInteraction();
        setPrompt('Now make the correct moves on the cube.');
        
        var moveIndex = 0;
        var expectedTwist = undefined;
        cube.addEventListener('onTwistComplete', verifyMove, false);
        
        function registerSuccessfulMove() {
          ++moveIndex;
          if (moveIndex >= numMoves) {
            finishRound();
          }
        }
        
        function finishRound() {
          cube.removeEventListener('onTwistComplete', verifyMove);
          
          // If this was the last round, then the player has won.
          if (numMoves >= algorithm.length) {
            win();
          }
          // Otherwise, play the next round.
          else {
            setPrompt('Good job. Now get ready to memorize ' + 
                      (movesPerRound > 1 ? 'more moves.' : 'one more move.'));
                
            resetCube();
            disableInteraction();
            performAlgorithmInstantly(inverse);
            
            setTimeout(function() {
              startMemorizationPhase(algorithm, inverse, numMoves + movesPerRound);
            }, breakDuration);
          }
        }
        
        function verifyMove(event) {
          // This loop will capture and ignore all the events dispatched by the cube when the
          // inverse algorithm is performed.
          for (var i = 0; i < inverse.length; ++i) {
            if (event.detail.twist === inverse[i]) {
              return;
            }
          }
          
          var correctTwist = false;
          // If expectedTwist is undefined at this point, it means that the current move is
          // expected, but if the current move is a half turn, then a quarter turn of the same face
          // is also allowed.
          if (expectedTwist === undefined) {
            expectedTwist = algorithm[moveIndex];
            if (event.detail.twist.functionallyEquals(expectedTwist)) {
              correctTwist = true;
            }
            // If the player only made a quarter turn when they should have made a half turn,
            // then they must perform the exact same quarter turn again.
            else if ((expectedTwist.degrees === 180 || expectedTwist.degrees === -180) &&
                     event.detail.twist.command.toUpperCase() === expectedTwist.command.toUpperCase()) {
              expectedTwist = event.detail.twist;
              return;
            }
          }
          // If expectedTwist is defined at this point, then that exact twist is expected, no exceptions.
          else {
            correctTwist = event.detail.twist.functionallyEquals(expectedTwist);
          }
          
          expectedTwist = undefined;
          
          if (correctTwist) {
            registerSuccessfulMove();
          }
          else {
            fail();
          }
        }
      }
      
      function win() {
        setPrompt('You win!');
        show(restartArea);
      }
      
      function fail() {
        setPrompt('Wrong!');
        show(restartArea);
      }
      
      function restart() {
        clear(prompt);
        resetCube();
        hide(restartArea);
        show(setupArea);
      }
    </script>
  </body>
</html>
