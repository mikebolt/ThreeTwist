<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" lang="en"/>
    <title>Algorithm Memorization Game</title>
    <link rel="stylesheet" href="../build/styles/cube.css"/>
    <script src="../build/ThreeTwist.js"></script>
  </head>
  
  <div id="cubeContainer" style="width: 50%; height: 400px;">
  </div>
  
  <h2 id="prompt">
  </h2>
  
  <div id="setupArea">
    <span>Algorithm to memorize:</span><input id="algorithmTextbox" type="text" value="R U R' U R U2 R'"/><br/>
    <span>Memorization duration:</span><input id="memorizationDurationTextbox" type="text" value="2"/><span>(seconds)</span><br/>
    <span>Between-rounds break duration:</span><input id="breakDurationTextbox" type="text" value="4"/><span>(seconds)</span><br/>
    <input id="startButton" type="button" value="Start"/>
  </div>
  
  <div id="restartArea" style="display: none">
    <input id="restartButton" type="button" value="Restart"/>
  </div>
  
  <body>
    <script>
      var cube;
      
      var cubeContainer = document.getElementById('cubeContainer');
      var prompt = document.getElementById('prompt');
      var setupArea = document.getElementById('setupArea');
      var algorithmTextbox = document.getElementById('algorithmTextbox');
      var memorizationDurationTextbox = document.getElementById('memorizationDurationTextbox');
      var breakDurationTextbox = document.getElementById('breakDurationTextbox');
      var startButton = document.getElementById('startButton');
      var restartArea = document.getElementById('restartArea');
      var restartButton = document.getElementById('restartButton');
      
      var memorizationDuration;
      var breakDuration;
      var defaultTwistDuration = 500;
      
      startButton.onclick = startMemorization;
      restartButton.onclick = restart;
      resetCube();
      
      function resetCube() {
        cubeContainer.innerHTML = 'Please wait a second while the cube loads.';
        if (cube !== undefined) {
          cube.destroy();
        }
        cube = new ThreeTwist.Cube();
        clear(cubeContainer);
        cubeContainer.appendChild(cube.domElement);
      }
      
      function enableInteraction() {
        cube.mouseControlsEnabled = true;
        document.addEventListener('keypress', cube.keypressListener);
      }
      
      function disableInteraction() {
        cube.mouseControlsEnabled = false;
        document.removeEventListener('keypress', cube.keypressListener);
      }
      
      function setPrompt(promptText) {
        prompt.innerHTML = promptText;
      }
      
      function clear(element) {
        element.innerHTML = '';
      }
      
      function hide(element) {
        element.style.display = 'none';
      }
      
      function show(element) {
        element.style.display = '';
      }
      
      // Returns a string representing a single twist/move.
      function twistToString(twist) {
        var suffix = '';
        if (twist.degrees === 180) {
          suffix = '2';
        }
        else if (twist.command === twist.command.toLowerCase()) {
          if (twist.degrees === 90) {
            suffix = "'";
          }
        }
        else if (twist.command === twist.command.toUpperCase()) {
          if (twist.degrees === -90) {
            suffix = "'";
          }
        }
        
        return twist.command.toUpperCase() + suffix;
      }
      
      function parseAlgorithm(algorithmString) {
        var algorithm = algorithmString.split(' ');
        moveArray = [];
        for (var i = 0; i < algorithm.length; ++i) {
          var command = algorithm[i].substring(0, 1);
          var angle = 90;
          if (algorithm[i].endsWith("2'") || algorithm[i].endsWith("'2")) {
            angle = -180;
          }
          else if (algorithm[i].endsWith("'")) {
            angle = -90;
          }
          else if (algorithm[i].endsWith('2')) {
            angle = 180;
          }
          var twist = new ThreeTwist.Twist(command, angle);
          if (twist) { // Invalid twists will be false
            moveArray.push(twist);
          }
        }
        
        return moveArray;
      }
      
      function inverseAlgorithm(moveArray) {
        var inversed = [];
        for (var i = moveArray.length - 1; i >= 0; --i) {
          inversed.push(moveArray[i].getInverse());
        }
        return inversed;
      }
      
      function performAlgorithmInstantly(algorithm) {
        var oldDuration = cube.twistDuration;
        cube.twistDuration = 0;
        algorithm.forEach(function(twist) {
          cube.immediateTwist(twist);
        });
        cube.twistDuration = oldDuration;
      }
      
      function startMemorization() {
        hide(setupArea);
        setPrompt('Get ready to memorize.');
        
        algorithm = parseAlgorithm(algorithmTextbox.value);
        inverse = inverseAlgorithm(algorithm);
        
        memorizationDuration = parseFloat(memorizationDurationTextbox.value, 10) * 1000;
        if (isNaN(memorizationDuration)) {
          memorizationDuration = 2000;
        }
        
        breakDuration = parseFloat(breakDurationTextbox.value, 10) * 1000;
        if (isNaN(breakDuration)) {
          breakDuration = 4000;
        }
        
        resetCube();
        disableInteraction();
        performAlgorithmInstantly(inverse);
        
        cube.twistDuration = memorizationDuration / 2;

        setTimeout(function() {
          
          testMemorization(algorithm, inverse, 1);
        }, breakDuration);
      }
      
      // This is sort of a recursive function.
      function testMemorization(algorithm, inverse, moveCount) {
        
        // Display the correct moves, up to moveCount, one at a time.
        var moveIndex = 0;
        disableInteraction();
        showNextMove();
        
        function showNextMove() {
          // If all the moves have been shown, start the test.
          if (moveIndex >= moveCount) {
            resetCube();
            performAlgorithmInstantly(inverse);
            
            moveIndex = 0;
            setPrompt('Now make the correct moves on the cube.');
            cube.twistDuration = defaultTwistDuration;
            enableInteraction();
            cube.addEventListener('onTwistComplete', twistEnforcer, false);
          }
          // Otherwise, show the next move.
          else {
            setPrompt(twistToString(algorithm[moveIndex]));
            console.log('duration: ' + cube.twistDuration);
            cube.immediateTwist(algorithm[moveIndex]);
            ++moveIndex;
            setTimeout(showNextMove, memorizationDuration);
          }
        }
        
        function twistEnforcer(event) {
          // This loop will capture and ignore all the events dispatched by the cube when the
          // inverse is performed.
          for (var i = 0; i < inverse.length; ++i) {
            if (event.detail.twist === inverse[i]) {
              return;
            }
          }
        
          expectedTwist = algorithm[moveIndex];
          if (event.detail.twist.equals(expectedTwist)) {
            ++moveIndex;
            if (moveIndex >= moveCount) {
              cube.removeEventListener('onTwistComplete', twistEnforcer);
              
              if (moveCount >= algorithm.length) {
                win();
              }
              else {
                setPrompt('Good job. Now get ready to memorize one more move.');
                
                resetCube();
                disableInteraction();
                performAlgorithmInstantly(inverse);
                
                setTimeout(function() {
                  testMemorization(algorithm, inverse, moveCount + 1);
                }, breakDuration);
              }
            }
          }
          else {
            fail();
          }
        }
      }
      
      function win() {
        setPrompt('You win!');
        show(restartArea);
      }
      
      function fail() {
        setPrompt('Wrong!');
        show(restartArea);
      }
      
      function restart() {
        clear(prompt);
        resetCube();
        hide(restartArea);
        show(setupArea);
      }
    </script>
  </body>
</html>
