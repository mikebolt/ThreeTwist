### Usages of string 'd' in file './src/scripts/extras/controls/locked.js':
ThreeTwist.Locked = function ( cube, camera, domElement ) {
  cube.domElement.ondragstart = function(){ return false; };
    enabled : true,
    rotationSpeed: 0.8,
  var projector = new ThreeTwist.Projector( cube, domElement ),
    direction = new THREE.Vector3(),
    pixelRatio = window.devicePixelRatio || 1;
    axisDefined = false;
  // Returns the bounding area of the element
  function getBoundingClientRect( element ){
    var bounds = element !== document ? element.getBoundingClientRect() : {
      width: window.innerWidth,
      height: window.innerHeight
     return bounds;
    if ( api.enabled && projector.getIntersection( camera, ( event.touches && event.touches[0] || event ).pageX, ( event.touches && event.touches[0] || event ).pageY ) === null ){
      screen = getBoundingClientRect( domElement );
      // If the current coordinates are outside the cube,
      // then this is a candidate for a full cube rotation.
          time = typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();
          domElement.removeEventListener( 'mousedown', onInteractStart );
          document.addEventListener( 'mousemove',    onInteractMove );
          document.addEventListener( 'mouseup',      onInteractEnd );
          domElement.removeEventListener( 'touchstart',onInteractStart );
          document.addEventListener( 'touchmove',    onInteractMove );
          document.addEventListener( 'touchend',      onInteractEnd );
    if( api.enabled ){
  function onInteractEnd( event ){
    domElement.addEventListener( 'mousedown',   onInteractStart );
    document.removeEventListener( 'mousemove',  onInteractMove );
    document.removeEventListener( 'mouseup',    onInteractEnd );
    domElement.addEventListener(  'touchstart', onInteractStart );
    document.removeEventListener( 'touchmove',   onInteractMove );
    document.removeEventListener( 'touchend',    onInteractEnd );
    if( axisDefined ){
      var command,
      // We have a group, but we need an associated command expressed as a single character.
        command = 'x';
        command = 'y';
        command = 'z';
      // Find the nearest 'complete' rotation
      angle = -Math.round( group.rotation / Math.PI * 2.0 ) * Math.PI * 0.5;
      velocity = direction.length() / (( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() ) - time );
      // If the gesture is faster than a predefined speed, then we assume this
      // is a swipe rather than a drag
        // If we are performing a 'z' twist, we should invert the rotation calculation
        if( command === 'z' ) {
        // Depending on the gesture direction we'll need to set the rotation to positive or negative
        angle = Math.round( absDirection.dot( direction.normalize() )) * Math.PI * 0.5 * sign;
      // We'll need to bound the rotation to 90 degree intervals to ensure
       // var origin = Math.round( group.rotation / Math.PI * 2.0 ) * Math.PI * 0.5;
      // Now that we have defined a twist, add it to the stack
      cube.twist( new ThreeTwist.Twist( command, angle.radiansToDegrees() ));
      var command;
          x - screen.width * pixelRatio * 0.5,
      // console.log( x - ( screen.width * pixelRatio * 0.5 ),
      //     y - ( screen.width * pixelRatio * 0.5 ) );
      inverse.getInverse( cube.matrixWorld );
      if     ( Math.abs( Math.round( axis.x )) === 1 ) {
        command = 'z';
      else if( Math.abs( Math.round( axis.y )) === 1 ) {
        command = 'y';
      else if( Math.abs( Math.round( axis.z )) === 1 ) {
        command = 'x';
      if( command === 'y' && x - screen.width * pixelRatio * 0.5 < 0 ) {
        command = command.toUpperCase();
      cube.twist( command );
    axisDefined = false;
    direction.set( 0, 0, 0 );
  //  This function provides a way to 'snap' a vector to it's closest axis.
  //  This is usefult to to determine a probable axis of rotation. It's fairly naive, but it works.
    vector.x = Math.round( vector.x / max );
  // For any given screen coordinates, this function
  // returns the face most likely to be associated with it.
      cube.object3D.updateMatrixWorld();
      matrixInverse.getInverse( cube.matrixWorld );
        // get the associated plane ...
        // and calculate where it intersects with the coordinates
        if( pointOfInteraction === undefined || intersection.z <= pointOfInteraction ){
  domElement.addEventListener( 'mousedown',   onInteractStart );
  domElement.addEventListener( 'touchstart',  onInteractStart );
  api.update = function(){
    // get a direction of movment
    direction.x = current.x - start.x;
    direction.y = current.y - start.y;
    // If we have not previously defined an axis of rotation,
    // for example, when a user begins interacting and the movement is not accidental,
    // then we can define a direction to rotate.
    if( !axisDefined && direction.length() > 30 /*&& ( start.x !== current.x || start.y !== current.y )*/){
      axisDefined = true;
      // Get an absolute directon, we use this to find signed rotation
      absDirection.copy( direction );
      absDirection.x = Math.round( absDirection.x );
      absDirection.y = Math.round( absDirection.y ) * ( 1.0 - Math.abs( absDirection.x ) );
      // Get a vector perpendicular to the direction
      axis.x = Math.round( axis.x );
      axis.y = Math.round( axis.y ) * ( 1.0 - Math.abs( axis.x ) );
      // If the axis is horizontal, then we could be rotating on one of two axes
            current.x - screen.width * pixelRatio * 0.5,
            current.y - screen.width * pixelRatio * 0.5 );
        inverse.getInverse( cube.matrixWorld );
        sign = -1 * ( Math.round( axis.x ) ||  Math.round( axis.y ) ||  Math.round( axis.z ));
      // Find out the associated cube group to rotate based on the axis of rotation.
      // but with a different axis of rotation.
      if     ( Math.abs( Math.round( axis.x )) === 1 ) {
      else if( Math.abs( Math.round( axis.y )) === 1 ) {
      else if( Math.abs( Math.round( axis.z )) === 1 ) {
    if( axisDefined ){
      angle = -absDirection.dot( direction ) / cube.size ;
      // group.rotation = Math.min( Math.PI * 0.5, Math.max( Math.PI * -0.5, angle * api.rotationSpeed ));
      group.rotation = angle * api.rotationSpeed;

### Usages of string 'd' in file './src/scripts/extras/deviceMotion.js':
function deviceMotion( cube, element ){
    bounds = getBoundingClientRect( element ),
    deviceOrientation = {},
    compassHeading, fixedAlpha,
    paused: false,
    decay: 0.1
  // Returns the bounding area of the element
  function getBoundingClientRect( element ){
    var bounds = element !== document ? element.getBoundingClientRect() : {
      width: window.innerWidth,
      height: window.innerHeight
    if( element !== document ){
      var d = element.ownerDocument.documentElement;
       bounds.left += window.pageXOffset - d.clientLeft;
       bounds.top  += window.pageYOffset - d.clientTop;
     return bounds;
  element.addEventListener( 'mousemove', function( event ){
    if( !api.paused ){
      x = event.pageX / bounds.width  * 2.0 - 1.0;
      y = event.pageY / bounds.height * 2.0 - 1.0;
  // The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''
    var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis
      euler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us
      quaternion.setFromEuler( euler );                               // orient the device
      quaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top
      quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation
  function update(){
    if( x !== undefined && y !== undefined ){
      cube.autoRotateObj3D.rotation.y += ( target.y - cube.autoRotateObj3D.rotation.y ) * api.decay;
      cube.autoRotateObj3D.rotation.x += ( target.x - cube.autoRotateObj3D.rotation.x ) * api.decay;
    requestAnimationFrame( update );
  requestAnimationFrame( update );

### Usages of string 'd' in file './src/scripts/extras/inspect.js':
//  Bear in mind this is merely one way to think about the Cube
//  and does require some redundancy in terms of Cubelet indexes.
//  Here we'll default to 'compact' mode in order to give the
ThreeTwist.Cube.prototype.inspect = function( compact, side ){
  this.front.inspect( compact, side );
  this.up.inspect(    compact, side );
  this.right.inspect( compact, side );
  this.down.inspect(  compact, side );
  this.left.inspect(  compact, side );
  this.back.inspect(  compact, side );
  if( face !== undefined ){
    //  Just a particular face's color -- called by Slice's inspector.
    //  Full on ASCII-art inspection mode -- with console colors!
    id      = this.id,
    address = this.address,
      if( justification !== undefined && minimumLength !== undefined ){
    if( id < 10 ) {
      id = '0' + id;
    if( address < 10 ) {
      address = '0' + address;
      '\n    ID         '+ id +
      '\n    Address    '+ address +
      '\n    Address X  '+ this.addressX.toSignedString() +
      '\n    Address Y  '+ this.addressY.toSignedString() +
      '\n    Address Z  '+ this.addressZ.toSignedString() +'\n'+
      '\n    Engaged X  '+ this.isEngagedX +
      '\n    Engaged Y  '+ this.isEngagedY +
      '\n    Engaged Z  '+ this.isEngagedZ +
      '\n%c 3  Down       '+ getColorName( 'down',  LEFT, 7 ) +'%c'+
      '\n               %cdown%c'+
      '\n           %c'+ getColorName( 'down', CENTER, 11 ) +'%c\n',
      this.down.color.styleB,  '',
      this.down.color.styleF,  '',
      this.down.color.styleF,  '',
      this.down.color.styleF,  ''
ThreeTwist.Slice.prototype.inspect = function( compact, side ){
    return cubelet[ side ].color.name.toUpperCase().justifyCenter( 9 );
  sideLabel = '';
  if( side === undefined ){
    if( this.face !== undefined ) {
      side = this.face;
      side = 'front';
  if( side instanceof ThreeTwist.Direction ) {
    side = side.name;
  if( side !== this.face ) {
    sideLabel = side + 's';
      '%c '+ this.northWest.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.north.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.northEast.id.toPaddedString( 2 ) +' %c '+
      '\n' + sideLabel +'\n'+
      '          %c '+ this.west.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.origin.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.east.id.toPaddedString( 2 ) +' %c '+
      '          %c '+ this.southWest.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.south.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.southEast.id.toPaddedString( 2 ) +' %c '+
      this.northWest[ side ].color.styleB, '',
      this.north[     side ].color.styleB, '',
      this.northEast[ side ].color.styleB, '',
      this.west[      side ].color.styleB, '',
      this.origin[    side ].color.styleB, '',
      this.east[      side ].color.styleB, '',
      this.southWest[ side ].color.styleB, '',
      this.south[     side ].color.styleB, '',
      this.southEast[ side ].color.styleB, ''
        '\n' + sideLabel.justifyLeft( 10 ) +
        '%c '+ this.northWest.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.north.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.northEast.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '          %c ' + this.west.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.origin.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.east.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '          %c ' + this.southWest.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.south.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.southEast.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, ''

### Usages of string 'd' in file './src/scripts/extras/renderers/iecss3d.js':
ThreeTwist.renderers = ThreeTwist.renderers || {};
ThreeTwist.renderers.IeCSS3D = (function(){
  //  This is a basic css renderer that uses a modified version of the three.js CSS3DRenderer.
  //  Having the renderer is a seperate file allows us to abstract all the visual components
  //  of the cube in a simple, straightforward way.
  //  and render it with the THREE.CSS3DRenderer. For projects with filesize restrictions,
  //  this is useful as it allows you to exclude the THREE.Scene and all it's dependancies entirely.
  //  The only caveat is that we need to temporarily define/re-define a dummy Scene object
    //   The IE Renderer only works when hideInvisible faces is true,
    //  otherwise you get depth sorting issues.
    cube.hideInvisibleFaces = true;
    var renderer   = new ThreeTwist.IeCss3DRenderer( cube ),
    renderer.scene = scene;
    // Add the cube 3D object to the scene
    scene.add( cube.autoRotateObj3D );
    scene.add( cube.camera );
    cube.domElement = renderer.domElement;
      faceLabel = cube[face.face].label = new THREE.CSS3DObject( document.createElement( 'div' ) );
      faceLabel.element.classList.add( 'faceLabel' );
      cube.object3D.add( faceLabel );
    cube.down.label.rotation.x   = Math.PI *  0.5;
    //  it has some useful information like a list of faces, but it doesn't have any visual component.
    //   Here we take the abstract cubelet and create something you can see.
    //  First we add some functionality to the ThreeTwist.Cubelet specific to css,
    //  things like setOpacity, and showStickers directly affects css styles.
    ThreeTwist.extend( ThreeTwist.Cubelet.prototype, ThreeTwist.renderers.IeCSS3DCubelet.methods );
    //   Then we use the CSS3DCubelet function to create all the dom elements.
    cubelets.forEach( ThreeTwist.renderers.IeCSS3DCubelet );
    function render(){
      if( cube.domElement.parentNode ){
        var parentWidth = cube.domElement.parentNode.clientWidth,
          parentHeight = cube.domElement.parentNode.clientHeight;
        if( cube.domElement.parentNode &&
          ( cube.domElement.clientWidth  !== parentWidth ||
          cube.domElement.clientHeight !== parentHeight )){
            cube.setSize( parentWidth, parentHeight );
        renderer.render( scene, cube.camera );
      requestAnimationFrame( render );
    requestAnimationFrame( render );
    // All renderers must return an object containing a domElement and an setSize method,
    // in most instances this is the renderer object itself.
    return renderer;
  // We'll need to set the scene object back to it's original type
ThreeTwist.renderers.IeCSS3DCubelet = (function(){
    cubelet.add( cubelet.css3DObject = new THREE.Object3D() );
    //  and create visual dom elements for each
    //  Here's our overhead for that:
      //  Each face is an object and keeps track of its original ID number
      // (which is important because its address will change with each rotation)
      //  its current color, and so on.
      face.object3D = new THREE.CSS3DObject( document.createElement( 'div' ));
      cubelet.css3DObject.add( face.object3D );
      //  This face of our Cubelet needs a DOM element for all the
      //  related DOM elements to be attached to.
      // var faceElement = document.createElement( 'div' );
      faceElement.classList.add( 'cubeletId-' + cubelet.id );
      faceElement.classList.add( 'face' );
      faceElement.classList.add( axisMap[face.id] );
      faceElement.classList.add( 'face' + ThreeTwist.Direction.getNameById( face.id ).capitalize() );
      // domElement.appendChild( this.faces[i].element );
      // this.css3DObject.element.appendChild( faceElement );
      var wireframeElement = document.createElement( 'div' );
      wireframeElement.classList.add( 'wireframe' );
      faceElement.appendChild( wireframeElement );
      //  For debugging we want the ability to display this Cubelet's ID number
      //  with an underline (to make numbers like 6 and 9 legible upside-down).
      var idElement = document.createElement( 'div' );
      idElement.classList.add( 'id' );
      faceElement.appendChild( idElement );
      var underlineElement = document.createElement( 'span' );
      underlineElement.classList.add( 'underline' );
      underlineElement.innerText = cubelet.id;
      idElement.appendChild( underlineElement );
      //  That means in a normal state (no twisting happening) it is entirely hidden.
        faceElement.classList.add( 'faceIntroverted' );
        if( cubelet.cube.hideInvisibleFaces ) {
          faceElement.style.display = 'none';
      //  But if this face does have a color then we need to
      //  and also allow text to be placed on it.
        faceElement.classList.add( 'faceExtroverted' );
        var stickerElement = document.createElement( 'div' );
        stickerElement.classList.add( 'sticker' );
        stickerElement.classList.add( face.color.name );
        faceElement.appendChild( stickerElement );
        //  One character per face, mostly for our branding.
        var textElement = document.createElement( 'div' );
        textElement.classList.add( 'text' );
        textElement.innerText = face.id;
        faceElement.appendChild( textElement );
    cubelet.front.object3D.element.classList.add( 'axisZ' );
    cubelet.back.object3D.element.classList.add( 'axisZ' );
    cubelet.right.object3D.element.classList.add( 'axisX' );
    cubelet.left.object3D.element.classList.add( 'axisX' );
    cubelet.up.object3D.element.classList.add( 'axisY' );
    cubelet.down.object3D.element.classList.add( 'axisY' );
    // Our faces all point in different directions so we'll need to rotate them individually
    cubelet.down.object3D.rotation.x   = Math.PI *  0.5;  cubelet.down.object3D.position.y   = -faceSpacing;
    //  We need to know if we're "engaged" on an axis
    //  which at first seems indentical to isTweening,
    //  until you consider partial rotations.
    cubelet.isEngagedX = false;
    cubelet.isEngagedY = false;
    cubelet.isEngagedZ = false;
    cubelet.hideIds();
    cubelet.hideTexts();
    cubelet.hideWireframes();
//   The method object contains functionality specific to the CSS3D renderer that we add
ThreeTwist.renderers.IeCSS3DCubelet.methods = function(){
    item.style.display = 'block';
  function hideItem( item ){
    item.style.display = 'none';
      return Array.prototype.slice.call( this.cube.domElement.querySelectorAll( '.cubeletId-'+ this.id + selectorString ));
    hide: function(){
      this.getFaceElements().forEach( hideItem );
      this.getFaceElements( '.faceExtroverted' ).forEach( showItem );
    hideExtroverts: function(){
      this.getFaceElements( '.faceExtroverted' ).forEach( hideItem );
          only = ( Math.abs( Math.round( axis.x )) === 1 ) ? '.axisX' : ( Math.round( Math.abs( axis.y )) === 1 ) ? '.axisY' : '.axisZ';
        this.getFaceElements( '.faceIntroverted' + only ).forEach( showItem );
    hideIntroverts: function(){
          only = ( Math.abs( Math.round( axis.x )) === 1 ) ? '.axisX' : ( Math.round( Math.abs( axis.y )) === 1 ) ? '.axisY' : '.axisZ';
        this.getFaceElements( '.faceIntroverted' + only ).forEach( hideItem );
    hidePlastics: function(){
        item.classList.add( 'faceTransparent' );
    hideStickers: function(){
      this.getFaceElements( ' .sticker' ).forEach( hideItem );
    hideWireframes: function(){
      this.getFaceElements( ' .wireframe' ).forEach( hideItem );
    showIds: function(){
      this.getFaceElements( ' .id' ).forEach( showItem );
      this.showingIds = true;
    hideIds: function(){
      this.getFaceElements( ' .id' ).forEach( hideItem );
      this.showingIds = false;
    hideTexts: function(){
      this.getFaceElements( ' .text' ).forEach( hideItem );
      if( opacityTarget === undefined ) {
        .easing( TWEEN.Easing.Quadratic.InOut )
        .onUpdate( function(){
      if( value === undefined ) {

### Usages of string 'd' in file './src/scripts/extras/renderers/ierenderer.js':
 * Based on THREE.CSSRenderer http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 * The IeCss3DRenderer is a heavily influenced/modified version of the THREE.CSS3DRenderer. It is designed to circumvent
 * the annoyingly problematic fact that IE 10/11 does not support the 'preserve-3d' property which means we need to calculate
 * and apply the model view matrix to each dom elements individually. Not only this, but it needs a manual depth sorting
 * routine. Painter sort just doesn't cut the mustard.
 * For those reasons, this renderer is not general purpose, it only works with Cuber. It makes a lot of assumptions about
 * the elements it's rendering. It could be possible to refactor this into a generalised CSS 3D renderer for IE, but not
 * NOTE: This isn't entirely bug free. There are some visible glitches when the depth sorting is incorrect.
  this.addEventListener( 'removed', function ( event ) {
    if ( this.element.parentNode !== null ) {
      this.element.parentNode.removeChild( this.element );
      for ( var i = 0, l = this.children.length; i < l; i ++ ) {
        this.children[ i ].dispatchEvent( event );
ThreeTwist.IeCss3DRenderer = function ( cube ) {
  var _width, _height;
  var _widthHalf, _heightHalf;
  var domElement = document.createElement( 'div' );
  domElement.style.overflow = 'hidden';
  this.domElement = domElement;
  var cameraElement = document.createElement( 'div' );
  domElement.appendChild( cameraElement );
  this.setSize = function ( width, height ) {
    _width = width;
    _widthHalf = _width / 2;
    domElement.style.width = width + 'px';
    domElement.style.height = height + 'px';;
    cameraElement.style.width = width + 'px';
      matrix.decompose( position, quaternion, scale );
       return 'translate3d(-50%,-50%,0) translate3d(' + epsilon( position.x ) + 'px, ' + epsilon( position.y ) + 'px, ' + epsilon( position.z ) + 'px) '
           + 'rotateX(' + epsilon( euler.x ) + 'rad) rotateY(' + epsilon( euler.y ) + 'rad) rotateZ(' + epsilon( euler.z ) + 'rad) '
           + 'scale3d(' + epsilon( scale.x ) + ', ' + epsilon( scale.y ) + ', ' + epsilon( scale.z ) + ')';
  var matrixWorld = new THREE.Matrix4();
  var renderCount;
      viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  var renderObject = function ( object, camera ) {
    matrixWorld.multiplyMatrices( cameraMatrix, object.matrixWorld );
    matrixWorld.elements[4] *= -1;
    matrixWorld.elements[5] *= -1;
    matrixWorld.elements[6] *= -1;
    matrixWorld.elements[7] *= -1;
    style =  getObjectCSSTransform( matrixWorld  );
    if ( element.parentNode !== cameraElement ) {
      cameraElement.appendChild( element );
    obj.userData.points[0].set( -halfCubeletSize, -halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
    obj.userData.points[1].set(  halfCubeletSize, -halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
    obj.userData.points[2].set(  halfCubeletSize,  halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
    obj.userData.points[3].set( -halfCubeletSize,  halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
  var sameSide = function(){
      delta = new THREE.Vector3(),
      normal.set( 0, 0, 1 ).transformDirection( a.matrixWorld );
      origin.set( 0, 0, 0 ).applyMatrix4( a.matrixWorld );
        delta.subVectors( points[i], origin );//.normalize();
        if(  epsilon( normal.dot( delta )) < 0 ) {
  function sharedEdge( a, b ){
    var sharedVertices = 0;
        if( epsilon( a.userData.points[p].distanceTo( b.userData.points[q] )) === 0 ){
          sharedVertices++;
    return sharedVertices > 1;
  var firstRender = true;
  var renderList = [];
  this.render = function ( scene, camera ) {
    fov = 0.5 / Math.tan( THREE.Math.degToRad( camera.fov * 0.5 ) ) * _height;
    domElement.style.WebkitPerspective = fov + "px";
    domElement.style.MozPerspective = fov + "px";
    domElement.style.oPerspective = fov + "px";
    domElement.style.perspective = fov + "px";
    scene.updateMatrixWorld();
    if ( camera.parent === undefined ) {
      camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse( camera.matrixWorld );
    screenCenter.makeTranslation( _widthHalf, -_heightHalf, 0 );
    cameraMatrix.multiply( camera.matrixWorldInverse );    // Get view
    cameraMatrix.multiply( fovOffset );            // Add FOV offset
    renderList = [];
        if( firstRender ){
          if( face.object3D.userData.min === undefined ){
        renderList.push( face.object3D );
    var sorted, p1z, p2z;
    renderList.sort( function( a, b ){
      sorted = sortVerts( a, camera );
      p1z = sorted[0].z;
      smallest( a.userData.min, sorted );
      largest( a.userData.max, sorted );
      sorted = sortVerts( b, camera );
      p2z = sorted[0].z;
      smallest( b.userData.min, sorted );
      largest( b.userData.max,  sorted );
      a.userData.zIndex = null;
      b.userData.zIndex = null;
    var aaa = cube.standing.northWest.front;
    var p = renderList.length, q, tmp, l = renderList.length;
      var P = renderList[p];
      P.userData.zIndex = ( P.userData.zIndex === null ) ? p : P.userData.zIndex;
        var Q = renderList[q];
        Q.userData.zIndex = ( Q.userData.zIndex === null ) ? q : Q.userData.zIndex;
          if( sameSide ( P, Q.userData.points )){
            tmp = P.userData.zIndex;
            P.userData.zIndex = Math.min( P.userData.zIndex, q  );
            Q.userData.zIndex = Math.max( tmp, q );
          else if( sameSide ( Q, P.userData.points )){
            tmp = Q.userData.zIndex;
            Q.userData.zIndex = Math.min( Q.userData.zIndex , P.userData.zIndex );
            P.userData.zIndex = Math.max( P.userData.zIndex, tmp  );
      objWorldPosition = new THREE.Vector3();
    for ( var i = 0, l = renderList.length; i < l; i ++ ) {
      renderObject( renderList[ i ], camera );
      objWorldPosition.set( renderList[i].matrixWorld.elements[12], renderList[i].matrixWorld.elements[13], renderList[i].matrixWorld.elements[14] );
      cam.subVectors( objWorldPosition, camera.position );
      facing =  normal.set( 0, 0, 1 ).transformDirection( renderList[i].matrixWorld ).dot( cam ) < 0;
      renderList[i].element.style.visibility = facing ? 'visible' : 'hidden';
      if( renderList[i] instanceof THREE.CSS3DObject ) {
        renderList[i].element.style.zIndex = renderList[i].userData.zIndex;
    firstRender = false;

### Usages of string 'd' in file './src/scripts/utils/Array.js':
ThreeTwist.extend( Array.prototype, {
  distanceTo : function( target ){
  middle : function(){
    return this[ Math.round(( this.length - 1 ) / 2 ) ];
  rand : function(){
    return this[ Math.floor( Math.random() * this.length )];
  random : function(){//  Convenience here. Exactly the same as .rand().
    return this[ Math.floor( Math.random() * this.length )];
      j = Math.floor( Math.random() * ( i + 1 ));
  toText : function( depth ){
    var i, indent, text;
    depth = _.cascade( depth, 0 );
    indent = '\n' + '\t'.multiply( depth );
        text += indent + this[ i ].toText( depth + 1 );
        text += indent + this[ i ];

### Usages of string 'd' in file './src/scripts/utils/Number.js':
ThreeTwist.extend( Number.prototype, {
  add : function(){
  degreesToDirection : function(){
    var d = this % 360,
    directions = [ 'N', 'NNE', 'NE', 'NEE', 'E', 'SEE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'SWW', 'W', 'NWW', 'NW', 'NNW', 'N' ];
    return directions[ this.scale( 0, 360, 0, directions.length - 1 ).round() ];
  degreesToRadians : function(){
  divide : function(){
    return Math.log( this ) / ( base === undefined ? 1 : Math.log( base ));
    // is this more pragmatic? ---> return ( '' + this.round() ).length;
  modulo : function( n ){
  radiansToDegrees : function(){
  rand : function( n ){
    if( n !== undefined ){
      return min + Math.floor( Math.random() * ( max - min ));
    return Math.floor( Math.random() * this );
  random : function( n ){
    if( n !== undefined ){
      return min + Math.random() * ( max - min );
    return Math.random() * this;
  remainder : function( n ){
  round : function( decimals ){
    decimals = decimals || 0;
    n *= Math.pow( 10, decimals );
    n  = Math.round( n );
    n /= Math.pow( 10, decimals );
  roundDown : function(){
  roundUp : function(){
  toPaddedString : function( padding ){
    return ( '0000000000000' + String( this )).slice( -padding );
  toSignedString : function(){
    var stringed = '' + this;
      stringed = '+' + stringed;
    return stringed;

### Usages of string 'd' in file './src/scripts/utils/String.js':
ThreeTwist.extend( String.prototype, {
    thisLeftLength  = Math.round( this.length / 2 ),
    containerLeftLength  = Math.round( n / 2 ),
    padLeftLength  = containerLeftLength  - thisLeftLength,
    padRightLength = containerRightLength - thisRightLength,
    centered = this;
    if( padLeftLength > 0 ){
      while( padLeftLength -- ) {
        centered = ' ' + centered;
    else if( padLeftLength < 0 ){
      centered = centered.substr( padLeftLength * -1 );
    if( padRightLength > 0 ){
      while( padRightLength -- ) {
        centered += ' ';
    else if( padRightLength < 0 ){
      centered = centered.substr( 0, centered.length + padRightLength );
    return centered;
    var justified = this;
    while( justified.length < n ) {
      justified = justified + ' ';
    return justified;
    var justified = this;
    while( justified.length < n ) {
      justified = ' ' + justified;
    return justified;
    n = _.cascade( n, 2 );
      entities += '&#' + this.charCodeAt( i ) + ';';
    joined = split[ 0 ],
      joined += split[ i ].capitalize();
    return joined;
  directionToDegrees : function(){
    directions = [ 'N', 'NNE', 'NE', 'NEE', 'E', 'SEE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'SWW', 'W', 'NWW', 'NW', 'NNW', 'N' ],
    i = directions.indexOf( this.toUpperCase() );
    return i >= 0 ? i.scale( 0, directions.length - 1, 0, 360 ) : Number.NaN;
  toUnderscoreCase : function(){
    var underscored = this.replace( /[A-Z]+/g, function( $0 ){
    if( underscored.charAt( 0 ) === '_' ) {
      underscored = underscored.substr( 1 );
    return underscored.toLowerCase();
  toUnicode : function(){
    var i, u, unicode = '';
      u = this.charCodeAt( i ).toString( 16 ).toUpperCase();
      unicode += '\\u' + u;
    return unicode;

### Usages of string 'd' in file './src/scripts/utils/utils.js':
  cascade: function(){
      if( args[ i ] !== undefined ) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

### Usages of string 'd' in file './src/scripts/colors.js':
  At first it seemed like overkill, but then as the solvers and inspectors
  moved forward having these objects available became highly desirable.
  Sure, ES5 doesn't really have constants but the all-caps alerts you
  to the fact that them thar variables ought not to be messed with.
  @author Mark Lundin - http://www.mark-lundin.com
//  Global constants to describe sticker colors.
  'font-weight: bold; color: #888',
  'background-color: #F3F3F3; color: rgba( 0, 0, 0, 0.5 )'
  'font-weight: bold; color: #F60',
  'background-color: #F60; color: rgba( 255, 255, 255, 0.9 )'
  'font-weight: bold; color: #00D',
  'background-color: #00D; color: rgba( 255, 255, 255, 0.9 )'
  'red',
  'font-weight: bold; color: #F00',
  'background-color: #F00; color: rgba( 255, 255, 255, 0.9 )'
  'font-weight: bold; color: #0A0',
  'background-color: #0A0; color: rgba( 255, 255, 255, 0.9 )'
  'font-weight: bold; color: #ED0',
  'background-color: #FE0; color: rgba( 0, 0, 0, 0.5 )'

### Usages of string 'd' in file './src/scripts/controls.js':
  // Returns the bounding area of the element
  function getBoundingClientRect( element ){
    var bounds = element !== document ? element.getBoundingClientRect() : {
      width: window.innerWidth,
      height: window.innerHeight
     return bounds;
  return function ( object, camera, domElement ) {
      direction     = new THREE.Vector2,
      mouseEnd   = new THREE.Vector2(),
      projector = new ThreeTwist.Projector( object, domElement ),
        enabled: true,
        domElement: domElement,
        rotationSpeed: 4.0,
        damping: 0.25
      var view = getBoundingClientRect( api.domElement ),
        aspect = view.height / view.width;
      var dpr = window.devicePixelRatio || 1;
      x *= dpr;
      y *= dpr;
        ( x - view.width - view.left ) * 0.001 , // view.width,// * ( devicePixelRatio || 1 ) ,
        ( view.height + view.top - y ) * 0.001 // view.height// * aspect // ( devicePixelRatio || 1 )
    api.update = function(){
        modelViewInverse = new THREE.Matrix4();
      return function updateClosure () {
        if( api.enabled === false || state === STATE.NONE ) {
         //  define an axis to rotate on, this is basically at a tangent to the direction
        axis.set( direction.y, direction.x * -1, 0 ).normalize();
        //  The axis of rotation needs to be in mode view space, otherwise the rotation
        //  will happen in a really strange way. We therefore need to get the local rotation
        //  of the cube and the relative position of the camera and update our axis.
        modelViewInverse.getInverse( object.matrixWorld );
        modelViewInverse.multiply( camera.matrixWorld );
        axis.transformDirection( modelViewInverse );
        direction.multiplyScalar( 1.0 - Math.max( 0.0, Math.min( 1.0, api.damping )));
        //  Determine how far we've moved. This to determine how much to rotate by
        length = direction.length();
        //  Then we can rotate the cube based on how far the drag occured
        object.object3D.rotateOnAxis( axis, -length * api.rotationSpeed );
        //  If the rotation is below a certain threshold specified as a factor of the damping effect,
          mouse.add( direction );
     *  Define listeners for user initiated events
    function mousedown( event ) {
      if ( !api.enabled || event.which !== 1 ) {
        direction.multiplyScalar( 0 );
        api.domElement.removeEventListener( 'mousedown', mousedown );
        document.addEventListener( 'mousemove', mousemove );
        document.addEventListener( 'mouseup', mouseup );
      if ( api.enabled ){
        //  Get the delta between mouse positions
        direction.subVectors( mouse, lastPosition );
      document.removeEventListener( 'mousemove', mousemove );
      document.removeEventListener( 'mouseup', mouseup );
      api.domElement.addEventListener( 'mousedown', mousedown );
      if ( api.enabled ){
      if ( api.enabled && projector.getIntersection( camera, event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) === null ){
        direction.multiplyScalar( 0 );
        api.domElement.removeEventListener( 'touchstart', touchstart );
        document.addEventListener( 'touchend', touchend );
        document.addEventListener( 'touchmove', touchmove );
      if ( api.enabled ){
        getMouseProjectionOnBall( event.changedTouches[ 0 ].pageX, event.changedTouches[ 0 ].pageY, mouse );
        //  Get the delta between mouse positions
        direction.subVectors( mouse, lastPosition );
    function touchend( event ) {
      document.removeEventListener( 'touchend', touchend );
      document.removeEventListener( 'touchmove', touchmove );
      api.domElement.addEventListener( 'touchstart', touchstart );
      if ( api.enabled ){
    api.domElement.addEventListener( 'mousedown', mousedown );
    api.domElement.addEventListener( 'touchstart', touchstart );

### Usages of string 'd' in file './src/scripts/cubelets.js':
  Faces are mapped in a clockwise spiral from Front to Back:
  The faces[] Array is mapped to names for convenience:
    this.faces[ 3 ] === this.down
  Each Cubelet has an Index which is assigned during Cube creation
  and an Address which changes as the Cubelet changes location.
  Additionally an AddressX, AddressY, and AddressZ are calculated
  from the Address and represent the Cubelet's location relative
  For an overview of the Cubelet's data from the browser's console:
  @author Mark Lundin - http://www.mark-lundin.com
ThreeTwist.Cubelet = function( cube, id, colors ){
  //  Our Cube can directly address its Cubelet children,
  //  only fair the Cubelet can address their parent Cube!
  //  Each Cube has Cubletes numbered 0 through 26.
  //  Even if we're debugging (and not attached to an actual Cube)
  //  we need an ID number for later below
  //  when we derive positions and rotations for the Cubelet faces.
  this.id = id || 0;
  //  Our Cubelet's address is its current location on the Cube.
  //  When the Cubelet is initialized its ID and address are the same.
  //  This method will also set the X, Y, and Z components of the
  //  Cubelet's address on the Cube.
  this.setAddress( this.id );
  //  We're going to build Cubelets that are 140 pixels square.
  //  Yup. This size is hardwired in Cube.
  //  It is also hard-wired into the CSS, but we can't simply
  //  grab the style.getBoundingClientRect() value because
  //  that's a 2D measurement -- doesn't account for pos and rot.
  //  Now we can find our Cubelet's X, Y, and Z position in space.
  //  We only need this momentarily to create our Object3D so
  //  there's no need to attach these properties to our Cubelet object.
  x = this.addressX * ( this.size + epsilon ),
  y = this.addressY * ( this.size + epsilon ),
  z = this.addressZ * ( this.size + epsilon );
  this.updateMatrix();
  // // Add the cublet to the cube object
  this.cube.object3D.add( this );
  // var domElement = document.createElement( 'div' );
  // domElement.classList.add( 'cubelet' );
  // domElement.classList.add( 'cubeletId-'+ this.id );
  // this.css3DObject = new THREE.CSS3DObject( domElement );
  // this.css3DObject.name = 'css3DObject-' + this.id;
  // this.add( this.css3DObject );
  //  to build the six faces of our Cubelet.
  //  Here's our overhead for that:
  var extrovertedFaces = 0;
  if( colors === undefined ) {
  //  Now let's map one color per side based on colors[].
  //  Undefined values are allowed (and anticipated).
  //  We need to loop through the colors[] Array "manually"
  //  because Array.forEach() would skip the undefined entries.
    //  we need to know where it should be positioned and rotated.
    // (This is based on our above positions and rotations map.)
    //  Each face is an object and keeps track of its original ID number
    // (which is important because its address will change with each rotation)
    //  its current color, and so on.
    this.faces[ i ].id = i;
    this.faces[ i ].normal = ThreeTwist.Direction.getNameById( i );
  //   //  This face of our Cubelet needs a DOM element for all the
  //   //  related DOM elements to be attached to.
  //   var faceElement = document.createElement( 'div' );
  //   faceElement.classList.add( 'face' );
  //   faceElement.classList.add( 'face'+ ThreeTwist.Direction.getNameById( i ).capitalize() );
  //   this.css3DObject.element.appendChild( faceElement );
  //   var wireframeElement = document.createElement( 'div' );
  //   wireframeElement.classList.add( 'wireframe' );
  //   faceElement.appendChild( wireframeElement );
  //   //  For debugging we want the ability to display this Cubelet's ID number
  //   //  with an underline (to make numbers like 6 and 9 legible upside-down).
  //   var idElement = document.createElement( 'div' );
  //   idElement.classList.add( 'id' );
  //   faceElement.appendChild( idElement );
  //   var underlineElement = document.createElement( 'span' );
  //   underlineElement.classList.add( 'underline' );
  //   underlineElement.innerText = this.id;
  //   idElement.appendChild( underlineElement );
    //  That means in a normal state (no twisting happening) it is entirely hidden.
  //     faceElement.classList.add( 'faceIntroverted' );
    //  But if this face does have a color then we need to
    //  and also allow text to be placed on it.
      //  We're going to use the number of exposed sides
      //  to determine below what 'type' of Cubelet this is:
      //  Core, Center, Edge, or Corner.
      extrovertedFaces ++;
  //     faceElement.classList.add( 'faceExtroverted' );
  //     var stickerElement = document.createElement( 'div' );
  //     stickerElement.classList.add( 'sticker' );
  //     stickerElement.classList.add( color.name );
  //     faceElement.appendChild( stickerElement );
  //     //  One character per face, mostly for our branding.
  //     var textElement = document.createElement( 'div' );
  //     textElement.classList.add( 'text' );
  //     faceElement.appendChild( textElement );
  //  and counted the number of extroverted sides
  //  we can determine what 'type' of Cubelet this is.
    'edge',
  ][ extrovertedFaces ];
    this.down   = this.faces[ 3 ];
  // this.front.element.style.transform =  "rotateX(   0deg ) translateZ( "+faceSpacing+"px ) rotateZ(   0deg )";
  // this.up.element.style.transform =     "rotateX(  90deg ) translateZ( "+faceSpacing+"px ) rotateZ(   0deg )";
  // this.right.element.style.transform =   "rotateY(  90deg ) translateZ( "+faceSpacing+"px ) rotateZ(   0deg )";
  // this.down.element.style.transform =   "rotateX( -90deg ) translateZ( "+faceSpacing+"px ) rotateZ(  90deg )";
  // this.left.element.style.transform =   "rotateY( -90deg ) translateZ( "+faceSpacing+"px ) rotateZ( -90deg )";
  // this.back.element.style.transform =   "rotateY( 180deg ) translateZ( "+faceSpacing+"px ) rotateZ( -90deg )";
  // this.down.element.style.OTransform   = this.down.element.style.MozTransform =   this.down.element.style.WebkitTransform   = this.down.element.style.transform;
  //  we had better attach the logo to it!
  //  We need to know if we're "engaged" on an axis
  //  which at first seems indentical to isTweening,
  //  until you consider partial rotations.
  this.isEngagedX = false;
  this.isEngagedY = false;
  this.isEngagedZ = false;
  // this.hideIds();
  // this.hideTexts();
  // this.hideWireframes();
  this.radius  = 0;
//  Let's add some functionality to Cubelet's prototype
//  By adding to Cubelet's prototype and not the Cubelet constructor
//  we're keeping instances of Cubelet super clean and light.
ThreeTwist.extend( ThreeTwist.Cubelet.prototype, {
  //  Aside from initialization this function will be called
  //  by the Cube during remapping.
  //  The raw address is an integer from 0 through 26
  //  mapped to the Cube in the same fashion as this.id.
  //  The X, Y, and Z components each range from -1 through +1
  setAddress: function( address ){
    this.address  = address || 0;
    this.addressX = address.modulo( 3 ).subtract( 1 );
    this.addressY = address.modulo( 9 ).divide( 3 ).roundDown().subtract( 1 ) * -1;
    this.addressZ = address.divide( 9 ).roundDown().subtract( 1 ) * -1;
  //  If so, return a String decribing what face that color is on.
    if( face !== undefined ){
        'down',
  getRadius: function(){
    return this.radius;
  setRadius: function( radius, onComplete ){
    //  It's a shame that we can't do this whilst tweening
    //  rather than the actual radius. Can fix later.
    //  Current may produce unexpected results while shuffling. For example:
    //    cube.corners.setRadius( 90 )
    //  may cause only 4 corners instead of 6 to setRadius()
    //  because one side is probably engaged in a twist tween.
      radius = radius || 0;
      if( this.radius === undefined ) {
        this.radius = 0;
      if( this.radius !== radius ){
        //  Here's some extra cuteness to make the tween's duration
        //  proportional to the distance traveled.
        // var tweenDuration = ( this.radius - radius ).absolute().scale( 0, 100, 0, 1000 )
        var tweenDuration = ( this.radius - radius ).absolute(),
          obj = {radius:this.radius};
        .to( { radius: radius }, tweenDuration )
        .onUpdate( function(){
          this.position.set( this.addressX.multiply( this.size + obj.radius  ) + 0.2, this.addressY.multiply( this.size + obj.radius  ) + 0.2, this.addressZ.multiply( this.size + obj.radius  ) + 0.2 );
          this.updateMatrix();
          this.radius = obj.radius;
        }.bind( this ))
          this.position.set( this.addressX.multiply( this.size + obj.radius  ) + 0.2, this.addressY.multiply( this.size + obj.radius  ) + 0.2, this.addressZ.multiply( this.size + obj.radius  ) + 0.2 );
          this.updateMatrix();
          this.radius = obj.radius;
        }.bind( this ))

### Usages of string 'd' in file './src/scripts/cubes.js':
  A Cube is composed of 27 Cubelets (3x3x3 grid) numbered 0 through 26.
  Cubelets are numbered beginning from the top-left-forward corner of the
  Cube and proceeding left to right, top to bottom, forward to back:
  Portions of the Cube are grouped (Groups):
    this.edges
  Portions of the Cube are grouped and rotatable (Slices):
  Rotatable around the Z axis:
    this.standing
  Rotatable around the X axis:
    this.middle
  Rotatable around the Y axis:
    this.down
  A Cube may be inspected through its Faces (see Slices for more
  This will reveal each Face's Cubelet indexes and colors using the Face's
  compact inspection mode. The non-compact mode may be accessed by passing
  @author Mark Lundin - http://www.mark-lundin.com
  this.paused             = parameters.paused === undefined ? false : parameters.paused;
  this.autoRotate          = parameters.autoRotate === undefined ? false : parameters.autoRotate;
  this.keyboardControlsEnabled  = parameters.keyboardControlsEnabled === undefined ? true : parameters.keyboardControlsEnabled;
  this.mouseControlsEnabled      = parameters.mouseControlsEnabled === undefined ? true : parameters.mouseControlsEnabled;
  var renderFactory         = parameters.renderer || ThreeTwist.renderers.CSS3D;
  //  This is useful for rendering purposes as browsers don't downsample textures very well, nor is upsamlping
  parameters.textureSize       = parameters.textureSize === undefined ? 120 : parameters.textureSize;
  this.isReady       = true;
  this.undoing     = false;
  this.render     = true;
  this.hideInvisibleFaces = parameters.hideInvisibleFaces === undefined ? false : parameters.hideInvisibleFaces;
  //   We'll keep an record of the number of moves we've made
  //  which can only be run if this.isReady === true.
  //  We need the ability to gang up twist commands.
  this.twistQueue = new ThreeTwist.Queue( ThreeTwist.Twist.validate );
  //  we also need a way to collect any undo requests into a similar queue
  this.historyQueue = new ThreeTwist.Queue( ThreeTwist.Twist.validate );
  //  How long should a Cube.twist() take?
  this.twistDuration = parameters.twistDuration !== undefined ? parameters.twistDuration : 500;
  //  If we shuffle, how shall we do it?
  this.shuffleMethod = this.PRESERVE_LOGO;
  //  Size matters? Cubelets will attempt to read these values.
  //  To display our cube, we'll need some 3D specific attributes, like a camera
  WIDTH         = window.innerWidth,
  HEIGHT        = window.innerHeight,
  //  To do all the things normaly associated with a 3D object
  //  we'll need to borrow a few properties from Three.js.
  //  Things like position rotation and orientation.
  this.matrixWorld= this.object3D.matrixWorld;
  //  by adding the following values to the Three object on each frame.
  //  We're going to map that front face from left to right (3), and top to bottom (3):
  //  But then behind the Front slice we also have a Standing slice (9) and Back slice (9),
    // TODO: This should be done programmatically.
    //  Standing slice
  ].forEach( function( cubeletColorMap, cubeletId ){
    this.cubelets.push( new ThreeTwist.Cubelet( this, cubeletId, cubeletColorMap ));
  }.bind( this ));
  //  that we will need later. (Demonstrated immediately below!)
  //  A Rubik's Cube is composed of 27 cubelets arranged 3 x 3 x 3.
  //  We need a map that relates these 27 locations to the 27 cubelets
  //  Their position and rotation is irrelevant.
  this.edges   = new ThreeTwist.Group();
  this.cubelets.forEach( function( cubelet, index ){
      this.core.add( cubelet );
      this.centers.add( cubelet );
    if( cubelet.type === 'edge'   ) {
      this.edges.add( cubelet );
      this.corners.add( cubelet );
    if( cubelet.type === 'center' || cubelet.type === 'edge') {
      this.crosses.add( cubelet );
  }.bind( this ));
  //  Now we'll create some slices. A slice represents a 3x3 grid of cubelets.
  this.middle = new ThreeTwist.Slice(
  this.middle.name = 'middle';
  this.right.neighbour = this.middle;
  this.left.neighbour = this.middle;
  this.down = new ThreeTwist.Slice(
  this.down.name = 'down';
  this.down.neighbour = this.equator;
  this.standing = new ThreeTwist.Slice(
  this.standing.name = 'standing';
  this.back.neighbour = this.standing;
  this.front.neighbour = this.standing;
  //  Faces .... special kind of Slice!
  this.faces = [ this.front, this.up, this.right, this.down, this.left, this.back ];
  this.slices = [ this.left, this.middle, this.right, this.down, this.equator, this.up, this.back, this.standing, this.front ];
  //   We also probably want a handle on any update events that occur, for example, when a slice is rotated
  var onSliceRotated = function( evt ){
    this.dispatchEvent( new CustomEvent( 'onTwistComplete', {detail: { slice : evt.target }}));
  }.bind( this );
    slice.addEventListener( 'change', onSliceRotated );
  var allIndices = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 ];
    's': this.standing,
    'd': this.down,
    'm': this.middle,
    //  Here we defined some arbitrary groups.
    //  there are however a few things about slices that we need,
    //  intents and purposes, we'll call them a slice
    'x': new ThreeTwist.Slice( allIndices, this ),
    'y': new ThreeTwist.Slice( allIndices, this ),
    'z': new ThreeTwist.Slice( allIndices, this )
  // Internally we have the ability to hide any invisible faces,
  // When a slice is rotated we determine what faces should be visible
  // so the cube doesn't look broken. This happend every time a slice is rotated.
  this.slicesDictionary.x.ableToHideInternalFaces = false;
  this.slicesDictionary.y.ableToHideInternalFaces = false;
  this.slicesDictionary.z.ableToHideInternalFaces = false;
  //  For the x,y and z groups we've defined above,
  //  we'll need to manually set an axis since once can't be automatically computed
  //  Good to let each Cubelet know where it exists
    cubelet.setAddress( i );
  //  Create a renderer object from the renderer factory.
  //   The renderFactory is a function that creates a renderer object
  this.renderer = renderFactory( this.cubelets, this );
  this.domElement = this.renderer.domElement;
  this.domElement.classList.add( 'cube' );
  this.domElement.style.fontSize = this.cubeletSize + 'px';
  this.autoRotateObj3D.add( this.object3D );
  if( this.hideInvisibleFaces ) {
    this.hideIntroverts( null, true );
  //  The Interaction class provides all the nifty mouse picking stuff.
  //  It's responsible for figuring out what cube slice is supposed to rotate
  //  and in what direction.
  this.mouseInteraction = new ThreeTwist.Interaction( this, this.camera, this.domElement );
  this.mouseInteraction.addEventListener( 'click', function( evt ){
    this.dispatchEvent( new CustomEvent("click", { detail: evt.detail  }));
  }.bind( this ));
  //  The Controls class rotates the entire cube around using an arcball implementation.
  //  You could override this with a different style of control
  this.controls = new ( parameters.controls || ThreeTwist.Controls )( this, this.camera, this.domElement );
  //  We need to map our folds separately from Cube.map()
  //  because we only want folds mapped at creation time.
  //  Remapping folds with each Cube.twist() would get weird...
  this.folds = [
    new ThreeTwist.Fold( this.front, this.right ),
    new ThreeTwist.Fold( this.left,  this.up    ),
    new ThreeTwist.Fold( this.down,  this.back  )
  //   Define a default size for our cube, this will be resized to 100%
  //  of it's containing dom element during the render.
  //  Get ready for major loop-age.
  this.loop = this.loop.bind( this );
  //  The cube needs to respond to user interaction and react accordingly.
  //  We'll set up a few event below to listen for specific commands,
  //  Enable key commands for our Cube.
  document.addEventListener( 'keypress', function( event ){
      this.keyboardControlsEnabled ){
        var key = String.fromCharCode( event.which );
        if( 'XxRrMmLlYyUuEeDdZzFfSsBb'.indexOf( key ) >= 0 ) {
  }.bind( this ));
ThreeTwist.extend( ThreeTwist.Cube.prototype, {
    //  How many times should we shuffle?
    //  Optional sequence of moves to execute instead of picking
                //  random moves from this.shuffleMethod.
    var moves = this.shuffleMethod.slice(),
      move, inverseOfLastMove = new ThreeTwist.Twist(), allowedMoves,
      sequenceLength = sequence.length, sequenceIndex = 0;
    //  We're shuffling the cube so we should clear any history
    //  Create some random rotations based on our shuffle method
        move.set(sequence[sequenceIndex]);
        sequenceIndex = (sequenceIndex + 1) % sequenceLength;
        allowedMoves = moves.split('');
        //  We don't want to chose a move that reverses the last shuffle, it just looks odd,
        //  so we should only select a move if it's a new one.
          move.set( allowedMoves.splice( Math.floor( Math.random() * allowedMoves.length  ), 1 )[0] );
      //  once we've executed it.
      //  Store a reference to the reverse of the move ( a twist that undoes the shuffle )
  isSolved: function(){
      this.front.isSolved( ThreeTwist.Direction.FRONT ) &&
      this.up.isSolved(    ThreeTwist.Direction.UP    ) &&
      this.right.isSolved( ThreeTwist.Direction.RIGHT ) &&
      this.down.isSolved(  ThreeTwist.Direction.DOWN  ) &&
      this.left.isSolved(  ThreeTwist.Direction.LEFT  ) &&
      this.back.isSolved(  ThreeTwist.Direction.BACK  );
  undo: function(){
      this.historyQueue.add( this.twistQueue.undo().getInverse() );
      this.undoing = true;
  redo: function(){
      this.undoing = true;
      this.historyQueue.add( this.twistQueue.redo() );
  twist: function( command ){
    if( this.undoing ) {
    this.undoing = false;
    this.twistQueue.add( command );
  immediateTwist: function( twist ){
        'Executing a twist command to rotate the '+
         twist.degrees, 'degrees.'
    //   We now need to find the slice to rotate and figure out how much we need to rotate it by.
    var slice    = this.slicesDictionary[ twist.command.toLowerCase() ],
      rotation = ( twist.degrees === undefined ? 90 : twist.degrees ) * twist.vector,
      radians  = rotation.degreesToRadians(),
      duration = Math.abs( radians - slice.rotation ) / ( Math.PI * 0.5 ) * this.twistDuration;
    var l = slice.indices.length,
      rotation: radians
    }, duration )
      slice.rotation = radians;
      // Invalidate our cubelet tweens
      l = slice.indices.length;
        cubelet.updateMatrix();
      //  If the rotation changes the cube then we should update the cubelet mapping
        slice.rotateGroupMappingOnAxis( radians );
        // Also, since everythings changed, we might aswell tell everyone
         this.dispatchEvent( new CustomEvent( 'onTwistComplete', { detail: {
         this.dispatchEvent( new CustomEvent( 'onShuffleComplete', { detail: {
    }.bind( this ))
  //  We can read and write text to the Cube.
  //  This is handled by Folds which are composed of two Faces.
  getText: function( fold ){
    if( fold === undefined ){
        this.folds[ 0 ].getText(),
        this.folds[ 1 ].getText(),
        this.folds[ 2 ].getText()
    else if( _.isNumeric( fold ) && fold >= 0 && fold <= 2 ){
      return this.folds[ fold ].getText();
  setText: function( text, fold ){
    if( fold === undefined ){
      this.folds[ 0 ].setText( text );
      this.folds[ 1 ].setText( text );
      this.folds[ 2 ].setText( text );
    else if( _.isNumeric( fold ) && fold >= 0 && fold <= 2 ){
      this.folds[ fold ].setText( text );
  setSize: function ( width, height ){
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize( width, height );
  //  Shuffle methods.
  PRESERVE_LOGO: 'RrLlUuDdSsBb',             //  Preserve the logo position and rotation.
  ALL_SLICES:    'RrMmLlUuEeDdFfSsBb',       //  Allow all slices to rotate.
  EVERYTHING:    'XxRrMmLlYyUuEeDdZzFfSsBb', //  Allow all slices, and also full cube X, Y, and Z rotations.
  //  The cube does its own loopage.
  //  and then tasks in the taskQueue.
  //  This is how shuffling and solving are handled.
      var localTime = ( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );
      if( !this.paused ){
        //  Update the internal animation frame
        TWEEN.update( this.time );
        //  If the Cube is "ready"
        //  and not a single cubelet is currently tweening
        //  regardless of it's resting state (engagement;
        //  meaning it could in theory not be tweening but
        if( this.isReady && this.isTweening() === 0 ){
          // if( this.twistQueue.isReady ){
            var queue = this.undoing ? this.historyQueue : this.twistQueue;
            //  so perhaps we'd like to add some?
              //  If the cube ought to be solving and a solver exists
              //  and we're not shuffling, tweening, etc.
              if( this.isSolving && window.solver ){
                this.isSolving = window.solver.consider( this );
              //  If we are doing absolutely nothing else
              else if( this.taskQueue.isReady === true ){
                var task = this.taskQueue.do();
            //  and we should put everything else aside and tend to those.
              var twist = queue.do();
              if( twist.command.toLowerCase() !== 'x' &&
                  twist.command.toLowerCase() !== 'y' &&
                  twist.command.toLowerCase() !== 'z' &&
                  twist.degrees !== 0  ) {
                this.moveCounter += this.undoing ? -1 : 1;
              //  If the twist we're about to execute does not actually
              //  then we don't need to remember it.
              if( twist.degrees === 0 || twist.isShuffle ) {
              this.immediateTwist( twist );
        // Our mouse controls should only be active if we are not rotating
        this.mouseInteraction.enabled = this.mouseControlsEnabled && !this.finalShuffle;
        this.mouseInteraction.update();
        this.controls.enabled = this.mouseControlsEnabled && !this.mouseInteraction.active;
        this.controls.update();

### Usages of string 'd' in file './src/scripts/directions.js':
  We have six Directions which we map in a spiral around a cube: front, up,
  right, down, left, and back. That's nice on its own but what's important
  Front face? Well that depends on what the Front face considers "up" to
  be. The ThreeTwist.Controls class handles these relationships and calculates clock-
  wise and anticlockwise relationships.
  The following equalities demonstrate how Directions operate:
    FRONT.getClockwise( RIGHT ).name === 'down'
  Keep in mind that a direction cannot use itself or its opposite as the
  normalized up vector when seeking a direction!
  @author Mark Lundin - http://www.mark-lundin.com
ThreeTwist.Direction = function( id, name, normal ){
  this.id        = id;
ThreeTwist.Direction.prototype.setRelationships = function( up, right, down, left, opposite ){
  this.neighbors = [ up, right, down, left ];
ThreeTwist.Direction.getNameById = function( id ){
    'down',
  ][ id ];
ThreeTwist.Direction.getIdByName = function( name ){
    down : 3,
ThreeTwist.Direction.getDirectionById = function( id ){
  ][ id ];
    down : ThreeTwist.Direction.DOWN,
    //  Flatten out any floating point rounding errors ...
    vector.x = Math.round( normal.x );
    vector.y = Math.round( normal.y );
    vector.z = Math.round( normal.z );
//  and we designate an adjacet side as up
//  then we can calculate what adjacent side would appear to be up
//  if we rotated clockwise or anticlockwise.
  if( from === undefined ) {
  steps = steps === undefined ? 1 : steps.modulo( 4 );
  return this.neighbors[ i.add( steps * vector ).modulo( 4 )];
//  and we designate an adjacet side as up
//  we can state what sides appear to be to the up, right, down, and left
ThreeTwist.Direction.prototype.getDirection = function( direction, up ){
  return this.getRotation( 1, up, direction.id - 1 );
//  An convenience method that mimics the verbiage
//  of the getRotation() and getDirection() methods.
//  Create facing directions as global constants this way we can access from
//  anywhere in any scope without big long variables names full of dots and
//  stuff. Sure, ES5 doesn't really have constants but the all-caps alerts you
//  to the fact that them thar variables ought not to be messed with.
ThreeTwist.Direction.DOWN  = new ThreeTwist.Direction( 3, 'down' , new THREE.Vector3(  0, -1,  0 ));

### Usages of string 'd' in file './src/scripts/extras/controls/locked.js':
ThreeTwist.Locked = function ( cube, camera, domElement ) {
  cube.domElement.ondragstart = function(){ return false; };
    enabled : true,
    rotationSpeed: 0.8,
  var projector = new ThreeTwist.Projector( cube, domElement ),
    direction = new THREE.Vector3(),
    pixelRatio = window.devicePixelRatio || 1;
    axisDefined = false;
  // Returns the bounding area of the element
  function getBoundingClientRect( element ){
    var bounds = element !== document ? element.getBoundingClientRect() : {
      width: window.innerWidth,
      height: window.innerHeight
     return bounds;
    if ( api.enabled && projector.getIntersection( camera, ( event.touches && event.touches[0] || event ).pageX, ( event.touches && event.touches[0] || event ).pageY ) === null ){
      screen = getBoundingClientRect( domElement );
      // If the current coordinates are outside the cube,
      // then this is a candidate for a full cube rotation.
          time = typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();
          domElement.removeEventListener( 'mousedown', onInteractStart );
          document.addEventListener( 'mousemove',    onInteractMove );
          document.addEventListener( 'mouseup',      onInteractEnd );
          domElement.removeEventListener( 'touchstart',onInteractStart );
          document.addEventListener( 'touchmove',    onInteractMove );
          document.addEventListener( 'touchend',      onInteractEnd );
    if( api.enabled ){
  function onInteractEnd( event ){
    domElement.addEventListener( 'mousedown',   onInteractStart );
    document.removeEventListener( 'mousemove',  onInteractMove );
    document.removeEventListener( 'mouseup',    onInteractEnd );
    domElement.addEventListener(  'touchstart', onInteractStart );
    document.removeEventListener( 'touchmove',   onInteractMove );
    document.removeEventListener( 'touchend',    onInteractEnd );
    if( axisDefined ){
      var command,
      // We have a group, but we need an associated command expressed as a single character.
        command = 'x';
        command = 'y';
        command = 'z';
      // Find the nearest 'complete' rotation
      angle = -Math.round( group.rotation / Math.PI * 2.0 ) * Math.PI * 0.5;
      velocity = direction.length() / (( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() ) - time );
      // If the gesture is faster than a predefined speed, then we assume this
      // is a swipe rather than a drag
        // If we are performing a 'z' twist, we should invert the rotation calculation
        if( command === 'z' ) {
        // Depending on the gesture direction we'll need to set the rotation to positive or negative
        angle = Math.round( absDirection.dot( direction.normalize() )) * Math.PI * 0.5 * sign;
      // We'll need to bound the rotation to 90 degree intervals to ensure
       // var origin = Math.round( group.rotation / Math.PI * 2.0 ) * Math.PI * 0.5;
      // Now that we have defined a twist, add it to the stack
      cube.twist( new ThreeTwist.Twist( command, angle.radiansToDegrees() ));
      var command;
          x - screen.width * pixelRatio * 0.5,
      // console.log( x - ( screen.width * pixelRatio * 0.5 ),
      //     y - ( screen.width * pixelRatio * 0.5 ) );
      inverse.getInverse( cube.matrixWorld );
      if     ( Math.abs( Math.round( axis.x )) === 1 ) {
        command = 'z';
      else if( Math.abs( Math.round( axis.y )) === 1 ) {
        command = 'y';
      else if( Math.abs( Math.round( axis.z )) === 1 ) {
        command = 'x';
      if( command === 'y' && x - screen.width * pixelRatio * 0.5 < 0 ) {
        command = command.toUpperCase();
      cube.twist( command );
    axisDefined = false;
    direction.set( 0, 0, 0 );
  //  This function provides a way to 'snap' a vector to it's closest axis.
  //  This is usefult to to determine a probable axis of rotation. It's fairly naive, but it works.
    vector.x = Math.round( vector.x / max );
  // For any given screen coordinates, this function
  // returns the face most likely to be associated with it.
      cube.object3D.updateMatrixWorld();
      matrixInverse.getInverse( cube.matrixWorld );
        // get the associated plane ...
        // and calculate where it intersects with the coordinates
        if( pointOfInteraction === undefined || intersection.z <= pointOfInteraction ){
  domElement.addEventListener( 'mousedown',   onInteractStart );
  domElement.addEventListener( 'touchstart',  onInteractStart );
  api.update = function(){
    // get a direction of movment
    direction.x = current.x - start.x;
    direction.y = current.y - start.y;
    // If we have not previously defined an axis of rotation,
    // for example, when a user begins interacting and the movement is not accidental,
    // then we can define a direction to rotate.
    if( !axisDefined && direction.length() > 30 /*&& ( start.x !== current.x || start.y !== current.y )*/){
      axisDefined = true;
      // Get an absolute directon, we use this to find signed rotation
      absDirection.copy( direction );
      absDirection.x = Math.round( absDirection.x );
      absDirection.y = Math.round( absDirection.y ) * ( 1.0 - Math.abs( absDirection.x ) );
      // Get a vector perpendicular to the direction
      axis.x = Math.round( axis.x );
      axis.y = Math.round( axis.y ) * ( 1.0 - Math.abs( axis.x ) );
      // If the axis is horizontal, then we could be rotating on one of two axes
            current.x - screen.width * pixelRatio * 0.5,
            current.y - screen.width * pixelRatio * 0.5 );
        inverse.getInverse( cube.matrixWorld );
        sign = -1 * ( Math.round( axis.x ) ||  Math.round( axis.y ) ||  Math.round( axis.z ));
      // Find out the associated cube group to rotate based on the axis of rotation.
      // but with a different axis of rotation.
      if     ( Math.abs( Math.round( axis.x )) === 1 ) {
      else if( Math.abs( Math.round( axis.y )) === 1 ) {
      else if( Math.abs( Math.round( axis.z )) === 1 ) {
    if( axisDefined ){
      angle = -absDirection.dot( direction ) / cube.size ;
      // group.rotation = Math.min( Math.PI * 0.5, Math.max( Math.PI * -0.5, angle * api.rotationSpeed ));
      group.rotation = angle * api.rotationSpeed;

### Usages of string 'd' in file './src/scripts/extras/deviceMotion.js':
function deviceMotion( cube, element ){
    bounds = getBoundingClientRect( element ),
    deviceOrientation = {},
    compassHeading, fixedAlpha,
    paused: false,
    decay: 0.1
  // Returns the bounding area of the element
  function getBoundingClientRect( element ){
    var bounds = element !== document ? element.getBoundingClientRect() : {
      width: window.innerWidth,
      height: window.innerHeight
    if( element !== document ){
      var d = element.ownerDocument.documentElement;
       bounds.left += window.pageXOffset - d.clientLeft;
       bounds.top  += window.pageYOffset - d.clientTop;
     return bounds;
  element.addEventListener( 'mousemove', function( event ){
    if( !api.paused ){
      x = event.pageX / bounds.width  * 2.0 - 1.0;
      y = event.pageY / bounds.height * 2.0 - 1.0;
  // The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''
    var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis
      euler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us
      quaternion.setFromEuler( euler );                               // orient the device
      quaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top
      quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation
  function update(){
    if( x !== undefined && y !== undefined ){
      cube.autoRotateObj3D.rotation.y += ( target.y - cube.autoRotateObj3D.rotation.y ) * api.decay;
      cube.autoRotateObj3D.rotation.x += ( target.x - cube.autoRotateObj3D.rotation.x ) * api.decay;
    requestAnimationFrame( update );
  requestAnimationFrame( update );

### Usages of string 'd' in file './src/scripts/extras/inspect.js':
//  Bear in mind this is merely one way to think about the Cube
//  and does require some redundancy in terms of Cubelet indexes.
//  Here we'll default to 'compact' mode in order to give the
ThreeTwist.Cube.prototype.inspect = function( compact, side ){
  this.front.inspect( compact, side );
  this.up.inspect(    compact, side );
  this.right.inspect( compact, side );
  this.down.inspect(  compact, side );
  this.left.inspect(  compact, side );
  this.back.inspect(  compact, side );
  if( face !== undefined ){
    //  Just a particular face's color -- called by Slice's inspector.
    //  Full on ASCII-art inspection mode -- with console colors!
    id      = this.id,
    address = this.address,
      if( justification !== undefined && minimumLength !== undefined ){
    if( id < 10 ) {
      id = '0' + id;
    if( address < 10 ) {
      address = '0' + address;
      '\n    ID         '+ id +
      '\n    Address    '+ address +
      '\n    Address X  '+ this.addressX.toSignedString() +
      '\n    Address Y  '+ this.addressY.toSignedString() +
      '\n    Address Z  '+ this.addressZ.toSignedString() +'\n'+
      '\n    Engaged X  '+ this.isEngagedX +
      '\n    Engaged Y  '+ this.isEngagedY +
      '\n    Engaged Z  '+ this.isEngagedZ +
      '\n%c 3  Down       '+ getColorName( 'down',  LEFT, 7 ) +'%c'+
      '\n               %cdown%c'+
      '\n           %c'+ getColorName( 'down', CENTER, 11 ) +'%c\n',
      this.down.color.styleB,  '',
      this.down.color.styleF,  '',
      this.down.color.styleF,  '',
      this.down.color.styleF,  ''
ThreeTwist.Slice.prototype.inspect = function( compact, side ){
    return cubelet[ side ].color.name.toUpperCase().justifyCenter( 9 );
  sideLabel = '';
  if( side === undefined ){
    if( this.face !== undefined ) {
      side = this.face;
      side = 'front';
  if( side instanceof ThreeTwist.Direction ) {
    side = side.name;
  if( side !== this.face ) {
    sideLabel = side + 's';
      '%c '+ this.northWest.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.north.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.northEast.id.toPaddedString( 2 ) +' %c '+
      '\n' + sideLabel +'\n'+
      '          %c '+ this.west.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.origin.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.east.id.toPaddedString( 2 ) +' %c '+
      '          %c '+ this.southWest.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.south.id.toPaddedString( 2 ) +' %c '+
      '%c '+ this.southEast.id.toPaddedString( 2 ) +' %c '+
      this.northWest[ side ].color.styleB, '',
      this.north[     side ].color.styleB, '',
      this.northEast[ side ].color.styleB, '',
      this.west[      side ].color.styleB, '',
      this.origin[    side ].color.styleB, '',
      this.east[      side ].color.styleB, '',
      this.southWest[ side ].color.styleB, '',
      this.south[     side ].color.styleB, '',
      this.southEast[ side ].color.styleB, ''
        '\n' + sideLabel.justifyLeft( 10 ) +
        '%c '+ this.northWest.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.north.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.northEast.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '          %c ' + this.west.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.origin.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.east.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '          %c ' + this.southWest.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.south.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        '%c '+ this.southEast.id.toPaddedString( 2 ).justifyCenter( 9 ) +' %c '+
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.northWest[ side ].color.styleB, '',
        this.north[     side ].color.styleB, '',
        this.northEast[ side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.west[      side ].color.styleB, '',
        this.origin[    side ].color.styleB, '',
        this.east[      side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, '',
        this.southWest[ side ].color.styleB, '',
        this.south[     side ].color.styleB, '',
        this.southEast[ side ].color.styleB, ''

### Usages of string 'd' in file './src/scripts/extras/renderers/iecss3d.js':
ThreeTwist.renderers = ThreeTwist.renderers || {};
ThreeTwist.renderers.IeCSS3D = (function(){
  //  This is a basic css renderer that uses a modified version of the three.js CSS3DRenderer.
  //  Having the renderer is a seperate file allows us to abstract all the visual components
  //  of the cube in a simple, straightforward way.
  //  and render it with the THREE.CSS3DRenderer. For projects with filesize restrictions,
  //  this is useful as it allows you to exclude the THREE.Scene and all it's dependancies entirely.
  //  The only caveat is that we need to temporarily define/re-define a dummy Scene object
    //   The IE Renderer only works when hideInvisible faces is true,
    //  otherwise you get depth sorting issues.
    cube.hideInvisibleFaces = true;
    var renderer   = new ThreeTwist.IeCss3DRenderer( cube ),
    renderer.scene = scene;
    // Add the cube 3D object to the scene
    scene.add( cube.autoRotateObj3D );
    scene.add( cube.camera );
    cube.domElement = renderer.domElement;
      faceLabel = cube[face.face].label = new THREE.CSS3DObject( document.createElement( 'div' ) );
      faceLabel.element.classList.add( 'faceLabel' );
      cube.object3D.add( faceLabel );
    cube.down.label.rotation.x   = Math.PI *  0.5;
    //  it has some useful information like a list of faces, but it doesn't have any visual component.
    //   Here we take the abstract cubelet and create something you can see.
    //  First we add some functionality to the ThreeTwist.Cubelet specific to css,
    //  things like setOpacity, and showStickers directly affects css styles.
    ThreeTwist.extend( ThreeTwist.Cubelet.prototype, ThreeTwist.renderers.IeCSS3DCubelet.methods );
    //   Then we use the CSS3DCubelet function to create all the dom elements.
    cubelets.forEach( ThreeTwist.renderers.IeCSS3DCubelet );
    function render(){
      if( cube.domElement.parentNode ){
        var parentWidth = cube.domElement.parentNode.clientWidth,
          parentHeight = cube.domElement.parentNode.clientHeight;
        if( cube.domElement.parentNode &&
          ( cube.domElement.clientWidth  !== parentWidth ||
          cube.domElement.clientHeight !== parentHeight )){
            cube.setSize( parentWidth, parentHeight );
        renderer.render( scene, cube.camera );
      requestAnimationFrame( render );
    requestAnimationFrame( render );
    // All renderers must return an object containing a domElement and an setSize method,
    // in most instances this is the renderer object itself.
    return renderer;
  // We'll need to set the scene object back to it's original type
ThreeTwist.renderers.IeCSS3DCubelet = (function(){
    cubelet.add( cubelet.css3DObject = new THREE.Object3D() );
    //  and create visual dom elements for each
    //  Here's our overhead for that:
      //  Each face is an object and keeps track of its original ID number
      // (which is important because its address will change with each rotation)
      //  its current color, and so on.
      face.object3D = new THREE.CSS3DObject( document.createElement( 'div' ));
      cubelet.css3DObject.add( face.object3D );
      //  This face of our Cubelet needs a DOM element for all the
      //  related DOM elements to be attached to.
      // var faceElement = document.createElement( 'div' );
      faceElement.classList.add( 'cubeletId-' + cubelet.id );
      faceElement.classList.add( 'face' );
      faceElement.classList.add( axisMap[face.id] );
      faceElement.classList.add( 'face' + ThreeTwist.Direction.getNameById( face.id ).capitalize() );
      // domElement.appendChild( this.faces[i].element );
      // this.css3DObject.element.appendChild( faceElement );
      var wireframeElement = document.createElement( 'div' );
      wireframeElement.classList.add( 'wireframe' );
      faceElement.appendChild( wireframeElement );
      //  For debugging we want the ability to display this Cubelet's ID number
      //  with an underline (to make numbers like 6 and 9 legible upside-down).
      var idElement = document.createElement( 'div' );
      idElement.classList.add( 'id' );
      faceElement.appendChild( idElement );
      var underlineElement = document.createElement( 'span' );
      underlineElement.classList.add( 'underline' );
      underlineElement.innerText = cubelet.id;
      idElement.appendChild( underlineElement );
      //  That means in a normal state (no twisting happening) it is entirely hidden.
        faceElement.classList.add( 'faceIntroverted' );
        if( cubelet.cube.hideInvisibleFaces ) {
          faceElement.style.display = 'none';
      //  But if this face does have a color then we need to
      //  and also allow text to be placed on it.
        faceElement.classList.add( 'faceExtroverted' );
        var stickerElement = document.createElement( 'div' );
        stickerElement.classList.add( 'sticker' );
        stickerElement.classList.add( face.color.name );
        faceElement.appendChild( stickerElement );
        //  One character per face, mostly for our branding.
        var textElement = document.createElement( 'div' );
        textElement.classList.add( 'text' );
        textElement.innerText = face.id;
        faceElement.appendChild( textElement );
    cubelet.front.object3D.element.classList.add( 'axisZ' );
    cubelet.back.object3D.element.classList.add( 'axisZ' );
    cubelet.right.object3D.element.classList.add( 'axisX' );
    cubelet.left.object3D.element.classList.add( 'axisX' );
    cubelet.up.object3D.element.classList.add( 'axisY' );
    cubelet.down.object3D.element.classList.add( 'axisY' );
    // Our faces all point in different directions so we'll need to rotate them individually
    cubelet.down.object3D.rotation.x   = Math.PI *  0.5;  cubelet.down.object3D.position.y   = -faceSpacing;
    //  We need to know if we're "engaged" on an axis
    //  which at first seems indentical to isTweening,
    //  until you consider partial rotations.
    cubelet.isEngagedX = false;
    cubelet.isEngagedY = false;
    cubelet.isEngagedZ = false;
    cubelet.hideIds();
    cubelet.hideTexts();
    cubelet.hideWireframes();
//   The method object contains functionality specific to the CSS3D renderer that we add
ThreeTwist.renderers.IeCSS3DCubelet.methods = function(){
    item.style.display = 'block';
  function hideItem( item ){
    item.style.display = 'none';
      return Array.prototype.slice.call( this.cube.domElement.querySelectorAll( '.cubeletId-'+ this.id + selectorString ));
    hide: function(){
      this.getFaceElements().forEach( hideItem );
      this.getFaceElements( '.faceExtroverted' ).forEach( showItem );
    hideExtroverts: function(){
      this.getFaceElements( '.faceExtroverted' ).forEach( hideItem );
          only = ( Math.abs( Math.round( axis.x )) === 1 ) ? '.axisX' : ( Math.round( Math.abs( axis.y )) === 1 ) ? '.axisY' : '.axisZ';
        this.getFaceElements( '.faceIntroverted' + only ).forEach( showItem );
    hideIntroverts: function(){
          only = ( Math.abs( Math.round( axis.x )) === 1 ) ? '.axisX' : ( Math.round( Math.abs( axis.y )) === 1 ) ? '.axisY' : '.axisZ';
        this.getFaceElements( '.faceIntroverted' + only ).forEach( hideItem );
    hidePlastics: function(){
        item.classList.add( 'faceTransparent' );
    hideStickers: function(){
      this.getFaceElements( ' .sticker' ).forEach( hideItem );
    hideWireframes: function(){
      this.getFaceElements( ' .wireframe' ).forEach( hideItem );
    showIds: function(){
      this.getFaceElements( ' .id' ).forEach( showItem );
      this.showingIds = true;
    hideIds: function(){
      this.getFaceElements( ' .id' ).forEach( hideItem );
      this.showingIds = false;
    hideTexts: function(){
      this.getFaceElements( ' .text' ).forEach( hideItem );
      if( opacityTarget === undefined ) {
        .easing( TWEEN.Easing.Quadratic.InOut )
        .onUpdate( function(){
      if( value === undefined ) {

### Usages of string 'd' in file './src/scripts/extras/renderers/ierenderer.js':
 * Based on THREE.CSSRenderer http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 * The IeCss3DRenderer is a heavily influenced/modified version of the THREE.CSS3DRenderer. It is designed to circumvent
 * the annoyingly problematic fact that IE 10/11 does not support the 'preserve-3d' property which means we need to calculate
 * and apply the model view matrix to each dom elements individually. Not only this, but it needs a manual depth sorting
 * routine. Painter sort just doesn't cut the mustard.
 * For those reasons, this renderer is not general purpose, it only works with Cuber. It makes a lot of assumptions about
 * the elements it's rendering. It could be possible to refactor this into a generalised CSS 3D renderer for IE, but not
 * NOTE: This isn't entirely bug free. There are some visible glitches when the depth sorting is incorrect.
  this.addEventListener( 'removed', function ( event ) {
    if ( this.element.parentNode !== null ) {
      this.element.parentNode.removeChild( this.element );
      for ( var i = 0, l = this.children.length; i < l; i ++ ) {
        this.children[ i ].dispatchEvent( event );
ThreeTwist.IeCss3DRenderer = function ( cube ) {
  var _width, _height;
  var _widthHalf, _heightHalf;
  var domElement = document.createElement( 'div' );
  domElement.style.overflow = 'hidden';
  this.domElement = domElement;
  var cameraElement = document.createElement( 'div' );
  domElement.appendChild( cameraElement );
  this.setSize = function ( width, height ) {
    _width = width;
    _widthHalf = _width / 2;
    domElement.style.width = width + 'px';
    domElement.style.height = height + 'px';;
    cameraElement.style.width = width + 'px';
      matrix.decompose( position, quaternion, scale );
       return 'translate3d(-50%,-50%,0) translate3d(' + epsilon( position.x ) + 'px, ' + epsilon( position.y ) + 'px, ' + epsilon( position.z ) + 'px) '
           + 'rotateX(' + epsilon( euler.x ) + 'rad) rotateY(' + epsilon( euler.y ) + 'rad) rotateZ(' + epsilon( euler.z ) + 'rad) '
           + 'scale3d(' + epsilon( scale.x ) + ', ' + epsilon( scale.y ) + ', ' + epsilon( scale.z ) + ')';
  var matrixWorld = new THREE.Matrix4();
  var renderCount;
      viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  var renderObject = function ( object, camera ) {
    matrixWorld.multiplyMatrices( cameraMatrix, object.matrixWorld );
    matrixWorld.elements[4] *= -1;
    matrixWorld.elements[5] *= -1;
    matrixWorld.elements[6] *= -1;
    matrixWorld.elements[7] *= -1;
    style =  getObjectCSSTransform( matrixWorld  );
    if ( element.parentNode !== cameraElement ) {
      cameraElement.appendChild( element );
    obj.userData.points[0].set( -halfCubeletSize, -halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
    obj.userData.points[1].set(  halfCubeletSize, -halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
    obj.userData.points[2].set(  halfCubeletSize,  halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
    obj.userData.points[3].set( -halfCubeletSize,  halfCubeletSize, 0 ).applyMatrix4( obj.matrixWorld );
  var sameSide = function(){
      delta = new THREE.Vector3(),
      normal.set( 0, 0, 1 ).transformDirection( a.matrixWorld );
      origin.set( 0, 0, 0 ).applyMatrix4( a.matrixWorld );
        delta.subVectors( points[i], origin );//.normalize();
        if(  epsilon( normal.dot( delta )) < 0 ) {
  function sharedEdge( a, b ){
    var sharedVertices = 0;
        if( epsilon( a.userData.points[p].distanceTo( b.userData.points[q] )) === 0 ){
          sharedVertices++;
    return sharedVertices > 1;
  var firstRender = true;
  var renderList = [];
  this.render = function ( scene, camera ) {
    fov = 0.5 / Math.tan( THREE.Math.degToRad( camera.fov * 0.5 ) ) * _height;
    domElement.style.WebkitPerspective = fov + "px";
    domElement.style.MozPerspective = fov + "px";
    domElement.style.oPerspective = fov + "px";
    domElement.style.perspective = fov + "px";
    scene.updateMatrixWorld();
    if ( camera.parent === undefined ) {
      camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse( camera.matrixWorld );
    screenCenter.makeTranslation( _widthHalf, -_heightHalf, 0 );
    cameraMatrix.multiply( camera.matrixWorldInverse );    // Get view
    cameraMatrix.multiply( fovOffset );            // Add FOV offset
    renderList = [];
        if( firstRender ){
          if( face.object3D.userData.min === undefined ){
        renderList.push( face.object3D );
    var sorted, p1z, p2z;
    renderList.sort( function( a, b ){
      sorted = sortVerts( a, camera );
      p1z = sorted[0].z;
      smallest( a.userData.min, sorted );
      largest( a.userData.max, sorted );
      sorted = sortVerts( b, camera );
      p2z = sorted[0].z;
      smallest( b.userData.min, sorted );
      largest( b.userData.max,  sorted );
      a.userData.zIndex = null;
      b.userData.zIndex = null;
    var aaa = cube.standing.northWest.front;
    var p = renderList.length, q, tmp, l = renderList.length;
      var P = renderList[p];
      P.userData.zIndex = ( P.userData.zIndex === null ) ? p : P.userData.zIndex;
        var Q = renderList[q];
        Q.userData.zIndex = ( Q.userData.zIndex === null ) ? q : Q.userData.zIndex;
          if( sameSide ( P, Q.userData.points )){
            tmp = P.userData.zIndex;
            P.userData.zIndex = Math.min( P.userData.zIndex, q  );
            Q.userData.zIndex = Math.max( tmp, q );
          else if( sameSide ( Q, P.userData.points )){
            tmp = Q.userData.zIndex;
            Q.userData.zIndex = Math.min( Q.userData.zIndex , P.userData.zIndex );
            P.userData.zIndex = Math.max( P.userData.zIndex, tmp  );
      objWorldPosition = new THREE.Vector3();
    for ( var i = 0, l = renderList.length; i < l; i ++ ) {
      renderObject( renderList[ i ], camera );
      objWorldPosition.set( renderList[i].matrixWorld.elements[12], renderList[i].matrixWorld.elements[13], renderList[i].matrixWorld.elements[14] );
      cam.subVectors( objWorldPosition, camera.position );
      facing =  normal.set( 0, 0, 1 ).transformDirection( renderList[i].matrixWorld ).dot( cam ) < 0;
      renderList[i].element.style.visibility = facing ? 'visible' : 'hidden';
      if( renderList[i] instanceof THREE.CSS3DObject ) {
        renderList[i].element.style.zIndex = renderList[i].userData.zIndex;
    firstRender = false;

### Usages of string 'd' in file './src/scripts/folds.js':
  Folds are two adjacent Faces joined together, as if one
  long 6 x 3 strip has been folding down the center and
  three such shapes together wrap the six sides of the Cube.
  Currently this is important for text wrapping. And in the
  future? Who knows. Characters in a String are mapped thus:
  Currently Folds are only intended to be created and
  heroized after the first Cube mapping. After the Cube
  twists things would get rather weird...
  @author Mark Lundin - http://www.mark-lundin.com
ThreeTwist.Fold = function( left, right ){
ThreeTwist.Fold.prototype.getText = function(){
ThreeTwist.Fold.prototype.setText = function( text ){

### Usages of string 'd' in file './src/scripts/groups.js':
  and therefore are not capable of rotation around any axis.
  @author Mark Lundin - http://www.mark-lundin.com
  this.add( Array.prototype.slice.call( arguments ));
ThreeTwist.extend( ThreeTwist.Group.prototype, THREE.EventDispatcher.prototype );
ThreeTwist.extend( ThreeTwist.Group.prototype, {
  add: function(){
    cubeletsToAdd = Array.prototype.slice.call( arguments ),
    cubeletsToAdd.forEach( function( cubelet ){
        that.add.apply( that, cubelet );
  //  Engaged on the Z axis? Etc.
  isFlagged: function( property ){
    return this.isFlagged( 'isTweening' );
  isEngagedX: function(){
    return this.isFlagged( 'isEngagedX' );
  isEngagedY: function(){
    return this.isFlagged( 'isEngagedY' );
  isEngagedZ: function(){
    return this.isFlagged( 'isEngagedZ' );
  isEngaged: function(){
    return this.isEngagedX() + this.isEngagedY() + this.isEngagedZ();
  //  And index? address? Solver uses these a lot.
        results.add( cubelet );
  hasId: function( id ){
    return this.hasProperty( 'id', id );
  hasAddress: function( address ){
    return this.hasProperty( 'address', address );
        results.add( cubelet );
        results.add( cubelet );
  //  cube.slices.front.isSolved( 'front' )
  //  cube.slices.front.up.isSolved( 'up' )
  isSolved: function( face ){
        if( faceColors[ color ] === undefined ){
      console.warn( 'A face [String or ThreeTwist.Controls] argument must be specified when using ThreeTwist.Group.isSolved().' );
  //  Take this group and hide all the stickers,
  //  turn on wireframe mode, etc.
  hide: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hide(); });
  hidePlastics: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hidePlastics(); });
  hideExtroverts: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hideExtroverts(); });
  hideIntroverts: function( only, soft ){
    this.cubelets.forEach( function( cubelet ){ cubelet.hideIntroverts( only, soft ); });
  hideStickers: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hideStickers(); });
  hideWireframes: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hideWireframes(); });
  showIds: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.showIds(); });
  hideIds: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hideIds(); });
  hideTexts: function(){
    this.cubelets.forEach( function( cubelet ){ cubelet.hideTexts(); });
  getRadius: function(){
    this.cubelets.forEach( function( cubelet ){ avg += cubelet.getRadius(); });
  setRadius: function( radius, onComplete ){
    this.cubelets.forEach( function( cubelet ){ cubelet.setRadius( radius, onComplete ); });

### Usages of string 'd' in file './src/scripts/interaction.js':
  This module handles all the user interactions with the cube.
  It figures out what slice to rotate and in what direction
  @author Mark Lundin - http://www.mark-lundin.com
  return function( cube, camera, domElement, dragSpeed, multiDrag ){
    var projector = new ThreeTwist.Projector( cube, domElement );
    var intersected, points = [],
      axisDefined = false,
      direction = new THREE.Vector3(),
    current.x = undefined;
    current.y = undefined;
      //  A boolean indicating when the user is interacting
      enabled: true,
      //  A boolean flag that, when enabled, allows the user to drag a slice on it's other axis
      //  A boolean flag that, when enabled, allows the user to drag a slice on it's other axis
      //  This sets the default drag speed.
      dragSpeed : dragSpeed || 1.3
        camera.matrixWorldInverse.getInverse( camera.matrixWorld );
        viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    //  This function provides a way to 'snap' a vector to it's closest axis.
    //  This is used to find a probable axis of rotation when a user performs a drag
    api.update = function (){
      if( api.enabled && api.active && x !== undefined && y !== undefined && ( mouseX !== x || mouseY !== y )) {
        //  As we already know what plane, or face, the interaction began on,
        //  we can then find the point on the plane where the interaction continues.
        direction.subVectors( pointOnPlane, intersection );
          if( !axisDefined && direction.length() > 5 /*|| ( api.multiDrag && direction.length() < api.multiDragSnapArea ) */ ){
            //  If we've already been rotating a slice but we want to change direction,
            //  for example if multiDrag is enabled, then we want to reset the original slice
          axisDefined = true;
          //  Once we have a plane, we can figure out what direction the user dragged
          //  and lock into an axis of rotation
          axis.crossVectors( plane.normal, direction );
          //  Of course, it's never a perfect gesture, so we should figure
          //  out the intended direction by snapping to the nearest axis.
          //  From the axis aligned vector, we can isolate the correct slice
          //  to rotate, by determining the index from the possible slices.
          // Determine the cross vector, or the direction relative to the axis we're rotating
        if( axisDefined ){
          //  By now, we already know what axis to rotate on,
          //  we just need to figure out by how much.
          direction.subVectors( pointOnPlane, intersection );
          var dot = cross.dot( direction );
          angle = dot / cube.size * api.dragSpeed;
      if( api.enabled && event.button !== 2 ){
        //  Here we find out if the mouse is hovering over the cube,
        //  If it is, then `intersection` is populated with the 3D local coordinates of where
        //  the intersection occured. `plane` is also configured to represent the face of the cube
        //  where the intersection occured. This is used later to determine the direction
        //  of the drag.
        if( intersected = projector.getIntersection( camera, mouseX, mouseY, intersection, plane ) ){
          //  If a interaction happens within the cube we should prevent the event bubbling.
          // event.stopImmediatePropagation();
            time = typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();
            //  Now we know the point of intersection, we can figure out what the associated cubelet is ...
            //  ... and the possible slices that might be rotated. Remeber, we can only figure out the exact slice once a drag happens.
            possibleSlices   = [ cube.slices[ cubelet.addressX + 1 ], cube.slices[ cubelet.addressY + 4 ], cube.slices[ cubelet.addressZ + 7 ]];
            //  Add a listener for interaction in the entire document.
            domElement.addEventListener( 'mousemove', onInteractUpdate );
            domElement.addEventListener( 'touchmove', onInteractUpdate );
            //  Add a lister to detect the end of interaction, remember this could happen outside the domElement, but still within the document
            domElement.addEventListener( 'mouseup', onInteractEnd );
            domElement.addEventListener( 'touchcancel', onInteractEnd );
            domElement.addEventListener( 'touchend', onInteractEnd );
            //  Whilst interacting we can temporarily remove the listeners detecting the start of interaction
            domElement.removeEventListener( 'mousedown', onInteractStart );
            domElement.removeEventListener( 'touchstart', onInteractStart );
    function onInteractUpdate( event ){
      // Prevent the default system dragging behaviour. ( Things like IOS move the viewport )
      if( api.enabled ){
        event.stopImmediatePropagation();
    function onInteractEnd( event ){
      //  When a user has finished interating, we need to finish off any rotation.
      //  We basically snap to the nearest face and issue a rotation command
      if( api.enabled && ( x !== mouseY || y !== mouseY ) && axisDefined ){
        // event.stopImmediatePropagation();
        //  Now we can get the direction of rotation and the associated command.
        var command =  slice.name[0].toUpperCase();
        //   We then find the nearest rotation to snap to and calculate how long the rotation should take
        //  based on the distance between our current rotation and the target rotation
        var targetAngle = Math.round( angle / Math.PI * 0.5 * 4.0 ) * Math.PI * 0.5;
        var velocityOfInteraction =  direction.length() / ( ( typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() ) - time );
          targetAngle += cross.dot( direction.normalize() ) > 0 ? Math.PI * 0.5: 0;
        //  then it doesn't really count as a move, and we don't need to add it to the history
        cube.twist( new ThreeTwist.Twist( command, targetAngle.radiansToDegrees() ));
      current.x = undefined;
      current.y = undefined;
      axisDefined = false;
      domElement.removeEventListener( 'mousemove', onInteractUpdate );
      domElement.removeEventListener( 'touchmove', onInteractUpdate );
      domElement.removeEventListener( 'mouseup', onInteractEnd );
      domElement.removeEventListener( 'touchend', onInteractEnd );
      domElement.removeEventListener( 'touchcancel', onInteractEnd );
      domElement.addEventListener( 'mousedown', onInteractStart );
      domElement.addEventListener( 'touchstart', onInteractStart );
    domElement.addEventListener( 'mousedown', onInteractStart );
    domElement.addEventListener( 'touchstart', onInteractStart );
    var detectInteraction = function ( x, y ){
        this.dispatchEvent( new CustomEvent("click", { detail: intersection  }));
    }.bind( api );
    domElement.addEventListener( 'mousedown', function( event ){
    domElement.addEventListener( 'mouseup', function( event ){
      if( !axisDefined && Math.abs( Math.sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay))) < 10 * ( window.devicePixelratio || 1 )){
        detectInteraction( ax, ay );
    domElement.addEventListener( 'touchstart', function( event ){
    domElement.addEventListener( 'touchend', function( event ){
      var bx = event.changedTouches[0].clientX,
        by = event.changedTouches[0].clientY;
      if( !axisDefined && Math.abs( Math.sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay))) < 10 * ( window.devicePixelratio || 1 )){
        if( detectInteraction( ax, ay )){

### Usages of string 'd' in file './src/scripts/main.js':
Made with love by:
@author Mark Lundin - http://mark-lundin.com / @mark_lundin
@author Stewart Smith - stewd.io
UPPERCASE = Clockwise to next 90 degree peg
lowercase = Anticlockwise to next 90 degree peg
S   Standing (rotate according to Front Face's orientation)
M   Middle (rotate according to Left Face's orientation)
E   Equator (rotate according to Up Face's orientation)
X   Rotate entire cube according to Right Face's orientation
Y   Rotate entire cube according to Up Face's orientation
Z   Rotate entire cube according to Front Face's orientation
http://en.wikipedia.org/wiki/Rubik's_Cube#Move_notation
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
    params = params || { bubbles: false, cancelable: false, detail: undefined };
    var evt = document.createEvent( 'CustomEvent' );
    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        fToBind = this,
        fBound = function () {
          return fToBind.apply(this instanceof fNOP && oThis
      fBound.prototype = new fNOP();
      return fBound;
// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767
ThreeTwist.extend = function ( obj, source ) {
  // ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/
      Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );

### Usages of string 'd' in file './src/scripts/projector.js':
  Converts mouse coordinates into 3D and detects mouse interaction
  @author Mark Lundin - http://www.mark-lundin.com
  //  The Cube Projector is a specialised class that detects mouse interaction.
  //  It's designed specifically for cubic geometry, in that it makes assumptions
  //  that cannot be applied to other 3D geometry. This makes the performance faster
  //  than other more generalised mouse picking techniques.
  return function( cube, domElement ){
      end   = new THREE.Vector3( 1, 1, 1 ),
      unitCubeBoundingRadius = mouse.distanceTo( end );
    //  Configure the bounding spehere and Axis Aligned Bounding Box dimensions.
    sphere.radius = unitCubeBoundingRadius * cube.size * 0.5;
    //  Utility function that unprojects 2D normalised screen coordinate to 3D.
      viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );
    // Returns the bounding area of the element
    function getBoundingClientRect( element ){
      var bounds = element !== document ? element.getBoundingClientRect() : {
        width: window.innerWidth,
        height: window.innerHeight
      if( element !== document ){
        var d = element.ownerDocument.documentElement;
         bounds.left += window.pageXOffset - d.clientLeft;
         bounds.top  += window.pageYOffset - d.clientTop;
       return bounds;
      //  Get the bounding area
      screen = getBoundingClientRect( domElement );
      //  Convert screen coords indo normalized device coordinate space
      mouse.x = ( mouseX - screen.left ) / screen.width * 2 - 1;
      end.set( mouse.x, mouse.y, 1.0 );
      //  Unproject screen coordinates into 3D
      unprojectVector( end, camera );
      // find direction from vector to end
      end.sub( mouse ).normalize();
      ray.set( mouse, end );
      //  Apply the world inverse
      inverseMatrix.getInverse( cube.matrixWorld );
     *   this returns a vector indicating the normal of the face
        .set( Math.round( target.x ), Math.round( target.y ), Math.round( target.z ))
     *  Given a three.js camera instance and a 2D mouse coordinates local to the domElement,
     *   this method tests for any intersection against the cube
     *  and returns a cubelet if one is found, otherwise it returns null indicating no intersection.
        //  If we haven't detected any mouse movement, then we've not made interacted!
        //  Check ray casting against the bounding sphere first as it's easier to compute,
        //  if it passes, then check the Axis Aligned Bounding Box.
            optionalPlaneTarget.setFromNormalAndCoplanarPoint( normal, intersection );
        //  If we haven't detected any mouse movement, then we've not interacted!
          //  Translate the world coordinates to a 3D index of the intersected cubelets location.
          tmp.copy( intersection ).add( box.max )
          //  Translate the 3D position to an array index

### Usages of string 'd' in file './src/scripts/queues.js':
  Queues are glorified Arrays and rather useful for things like our
  @author Mark Lundin - http://www.mark-lundin.com
ThreeTwist.Queue = function( validation ){
  //  Do we want to run a validation routine on objects being stored in
  //  this ThreeTwist.Queue? If so you can send the function as an argument to the
  if( validation !== undefined && validation instanceof Function ) {
    this.validate = validation;
  this.isReady = true;
//  The idea here with .add() is that .validate() will always return an Array.
//  The reason for this is that the validator may decide it needs to add more
//  than one element to the ThreeTwist.Queue. This allows it to do so.
ThreeTwist.Queue.prototype.add = function(){
  if( this.validate !== undefined && this.validate instanceof Function ) {
    elements = this.validate( elements );
    }.bind( this ));
    }.bind( this ));
    }.bind( this ));
ThreeTwist.Queue.prototype.do = function(){
ThreeTwist.Queue.prototype.undo = function(){
ThreeTwist.Queue.prototype.redo = function(){
  return this.do();

### Usages of string 'd' in file './src/scripts/renderer.js':
//  This is a basic css renderer that uses a modified version of the three.js CSS3DRenderer.
//  Having the renderer is a seperate file allows us to abstract all the visual components
//  of the cube in a simple, straightforward way.
//  and render it with the THREE.CSS3DRenderer. For projects with filesize restrictions,
//  this is useful as it allows you to exclude the THREE.Scene and all it's dependancies entirely.
//  The only caveat is that we need to temporarily define/re-define a dummy Scene object
ThreeTwist.renderers = ThreeTwist.renderers || {};
ThreeTwist.renderers.CSS3D = function( cubelets, cube ){
  var renderer = new THREE.CSS3DRenderer(),
  renderer.scene = scene;
  // Add the cube 3D object to the scene
  scene.add( cube.autoRotateObj3D );
  scene.add( cube.camera );
    faceLabel = cube[face.face].label = new THREE.CSS3DObject( document.createElement( 'div' ) );
    faceLabel.element.classList.add( 'faceLabel' );
    cube.object3D.add( faceLabel );
  cube.down.label.rotation.x   = Math.PI *  0.5;
    item.style.display = 'block';
  function hideItem( item ){
    item.style.display = 'none';
    return Array.prototype.slice.call( renderer.domElement.querySelectorAll( '.faceLabel' ));
  cube.hideFaceLabels = function(){
    getFaceLabelElements().forEach( hideItem );
  //  it has some useful information like a list of faces, but it doesn't have any visual component.
  //   Here we take the abstract cubelet and create something you can see.
  //  First we add some functionality to the ThreeTwist.Cubelet specific to css,
  //  things like setOpacity, and showStickers directly affects css styles.
  ThreeTwist.extend( ThreeTwist.Cubelet.prototype, ThreeTwist.renderers.CSS3DCubelet.methods );
  //   Then we use the CSS3DCubelet function to create all the dom elements.
  cubelets.forEach( ThreeTwist.renderers.CSS3DCubelet );
  function render(){
    if( cube.domElement.parentNode ){
      var parentWidth = cube.domElement.parentNode.clientWidth,
        parentHeight = cube.domElement.parentNode.clientHeight;
      if( cube.domElement.parentNode &&
        ( cube.domElement.clientWidth  !== parentWidth ||
        cube.domElement.clientHeight !== parentHeight )){
          cube.setSize( parentWidth, parentHeight );
      renderer.render( scene, cube.camera );
    requestAnimationFrame( render );
  requestAnimationFrame( render );
  // We'll need to set the scene object back to it's original type
  // All renderers must return an object containing a domElement and an setSize method,
  // in most instances this is the renderer object itself.
  return renderer;
ThreeTwist.renderers.CSS3DCubelet = (function(){
    var domElement = document.createElement( 'div' );
    domElement.classList.add( 'cubelet' );
    domElement.classList.add( 'cubeletId-'+ cubelet.id );
    cubelet.css3DObject = new THREE.CSS3DObject( domElement );
    cubelet.css3DObject.name = 'css3DObject-' + cubelet.id;
    cubelet.add( cubelet.css3DObject );
      "rotateX(   0deg ) translateZ( "+faceSpacing+"px ) rotateZ(   0deg )",
      "rotateX(  90deg ) translateZ( "+faceSpacing+"px ) rotateZ(   0deg )",
      "rotateY(  90deg ) translateZ( "+faceSpacing+"px ) rotateZ(   0deg )",
      "rotateX( -90deg ) translateZ( "+faceSpacing+"px ) rotateZ(  90deg )",
      "rotateY( -90deg ) translateZ( "+faceSpacing+"px ) rotateZ( -90deg )",
      "rotateY( 180deg ) translateZ( "+faceSpacing+"px ) rotateZ( -90deg )"
    //  and create visual dom elements for each
    //  Here's our overhead for that:
      //  This face of our Cubelet needs a DOM element for all the
      //  related DOM elements to be attached to.
      face.element = document.createElement( 'div' );
      face.element.classList.add( 'face' );
      face.element.classList.add( axisMap[ face.id ]);
      face.element.classList.add( 'face'+ ThreeTwist.Direction.getNameById( face.id ).capitalize() );
      cubelet.css3DObject.element.appendChild( face.element );
      var wireframeElement = document.createElement( 'div' );
      wireframeElement.classList.add( 'wireframe' );
      face.element.appendChild( wireframeElement );
      //  For debugging we want the ability to display this Cubelet's ID number
      //  with an underline (to make numbers like 6 and 9 legible upside-down).
      var idElement = document.createElement( 'div' );
      idElement.classList.add( 'id' );
      face.element.appendChild( idElement );
      var underlineElement = document.createElement( 'span' );
      underlineElement.classList.add( 'underline' );
      underlineElement.innerText = cubelet.id;
      idElement.appendChild( underlineElement );
      // Each face has a different orientation represented by a CSS 3D transform.
      // Here we select and apply the correct one.
      var cssTransform = transformMap[ face.id ],
      //  That means in a normal state (no twisting happening) it is entirely hidden.
        face.element.classList.add( 'faceIntroverted' );
        face.element.appendChild( document.createElement( 'div' ));
      //  But if this face does have a color then we need to
      //  and also allow text to be placed on it.
        face.element.classList.add( 'faceExtroverted' );
        var stickerElement = document.createElement( 'div' );
        stickerElement.classList.add( 'sticker' );
        stickerElement.classList.add( face.color.name );
        face.element.appendChild( stickerElement );
        //  we had better attach the logo to it!
          stickerElement.classList.add( 'stickerLogo' );
        //  One character per face, mostly for our branding.
        var textElement = document.createElement( 'div' );
        textElement.classList.add( 'text' );
        textElement.innerText = face.id;
        face.element.appendChild( textElement );
    cubelet.hideIds();
    cubelet.hideTexts();
    cubelet.hideWireframes();
//   The method object contains functionality specific to the CSS3D renderer that we add
ThreeTwist.renderers.CSS3DCubelet.methods = (function(){
    item.style.display = 'block';
  function hideItem( item ){
    item.style.display = 'none';
    hide: function(){
      hideItem( this.css3DObject.element );
      this.getFaceElements( '.faceExtroverted' ).forEach( showItem );
    hideExtroverts: function(){
      this.getFaceElements( '.faceExtroverted' ).forEach( hideItem );
          only = ( Math.abs( Math.round( axis.x )) === 1 ) ? '.axisX' : ( Math.round( Math.abs( axis.y )) === 1 ) ? '.axisY' : '.axisZ';
        this.getFaceElements( '.faceIntroverted' + ( onlyAxis !== undefined ? only : "" )).forEach( showItem );
    hideIntroverts: function(){
          only = ( Math.abs( Math.round( axis.x )) === 1 ) ? '.axisX' : ( Math.round( Math.abs( axis.y )) === 1 ) ? '.axisY' : '.axisZ';
        this.getFaceElements( '.faceIntroverted' + ( onlyAxis !== undefined ? only : "" )).forEach( hideItem );
    hidePlastics: function(){
        item.classList.add( 'faceTransparent' );
    hideStickers: function(){
      this.getFaceElements( ' .sticker' ).forEach( hideItem );
    hideWireframes: function(){
      this.getFaceElements( ' .wireframe' ).forEach( hideItem );
    showIds: function(){
      this.getFaceElements( ' .id' ).forEach( showItem );
      this.showingIds = true;
    hideIds: function(){
      this.getFaceElements( ' .id' ).forEach( hideItem );
      this.showingIds = false;
    hideTexts: function(){
      this.getFaceElements( ' .text' ).forEach( hideItem );
      if( opacityTarget === undefined ) {
        .easing( TWEEN.Easing.Quadratic.InOut )
        .onUpdate( function(){
      if( value === undefined ) {

### Usages of string 'd' in file './src/scripts/slices.js':
  Slices are thin layers sliced out of the Cube
  composed of 9 Cubelets (3x3 grid).
  The position of these Cubelets can be mapped as follows:
  The cubelets[] Array is mapped to names for convenience:
  Portions of Slices can be Grouped:
  Rows and columns as strips (1x3)
    this.down
    this.middle
    this.edges
    this.dexter
  A Slice may be inspected from the browser's JavaScript console with:
  This will reveal the Slice's Cubelets, their Indices, and colors.
  A compact inspection mode is also available:
  not Faces, or for special cases, it may be useful to send a side
  argument which is usually by default the Slice's origin's only visible
  side if it has one.
  For example, a Cube has 6 faces: front, up, right, down, left, back.
  itself: equator, middle, and standing. When a Slice maps itself it
  visible face. If it has a visible face then the Slice's face and the
  face's direction is in the direction of that Cubelet's visible face.
  This seems redundant from the Cube's perspective:
  However it becomes valuable from inside a Slice or Fold when a
  relationship to the Cube's orientation is not immediately clear:
  Therefore a Slice (s) is also a face if s.face !== undefined.
ThreeTwist.Slice = function( indices, cube ){
  this.invertedAxis = new THREE.Vector3();
  this.indices = indices;
  this.ableToHideInternalFaces = true;
  this.getCubelet = function( index ){
    return cube.cubelets[ indices[ index ]];
  // var displayInternalFaces = function( value ){
  //  Once we've performed a physical rotaion of a face or group, we need a way to remap the array of cubelets.
  //  This method does just that. Given a subset of cubelets, an axis to rotate on and
  //  an angle, it will shift the location of all cubelets that need changing.
    //   Here we pre-define a few properties.
    //  We'll reuse the, so it's best to define them up front
    //  to avoid allocating new memeory at runtime
      // therefore we should round to the nearest full rotation
      angle = Math.round( angle / ( Math.PI * 0.25 ) ) * Math.PI * 0.25;
      var i = indices.length,
        cubelet = cube.cubelets[ indices[ i ]];
        //  Get it's position and save it for later ...
        point.set( cubelet.addressX, cubelet.addressY, cubelet.addressZ );
        //  Flatten out any floating point rounding errors ...
        point.x = Math.round( point.x );
        point.y = Math.round( point.y );
        point.z = Math.round( point.z );
        //  rotate, and perform a mask-like operation.
        point.add( origin.multiply( this.axis ));
        point.add( max );
        //  The cublet array is in a funny order, so invert some of the axes of from our new position
        //  Use the X,Y,Z to get a 3D index
        var address = point.z * 9 + point.y * 3 + point.x;
        cube.cubelets[cubelet.address] = cubletsCopy[address];
      //  Good to let each Cubelet know where it exists
        cube.cubelets[ i ].setAddress( i );
      //   Remapping the location of the cubelets is all well and good,
      //  but we also need to reorientate each cubelets face so cubelet.front
        cubelet.faces.forEach( function( face, index ){
          // and find the index of the new direction and add it to the new array
          faceArray[ ThreeTwist.Direction.getDirectionByNormal( point ).id ] = face;
        cubelet.down   = cubelet.faces[ 3 ];
// THREE.extend( ThreeTwist.Slice.prototype, ThreeTwist.Group.prototype );
ThreeTwist.extend( ThreeTwist.Slice.prototype, {
  get origin(){   return this.cube.cubelets[ this.indices[ 4 ]];},
  get north(){   return this.cube.cubelets[ this.indices[ 1 ]];},
  get northEast(){return this.cube.cubelets[ this.indices[ 2 ]];},
  get east(){    return this.cube.cubelets[ this.indices[ 5 ]];},
  get southEast(){return this.cube.cubelets[ this.indices[ 8 ]];},
  get south(){  return this.cube.cubelets[ this.indices[ 7 ]];},
  get southWest(){return this.cube.cubelets[ this.indices[ 6 ]];},
  get west(){    return this.cube.cubelets[ this.indices[ 3 ]];},
  get northWest(){return this.cube.cubelets[ this.indices[ 0 ]];},
      l = this.indices.length;
  map: function( indices, cubelets ){
    // this.indices  = indices;
    //  we can determine if this is merely a Slice
    //  If a face we'll know what direction it faces
    //  and what the color of the face *should* be.
        this.face = ThreeTwist.Direction.getNameById( i );
    //   We also need to calculate what axis this slice rotates on.
    //  For example, the Right Slice (R) would rotate on the axis pointing to the right represented by the axis ( 1, 0, 0 )
    //  similarly the Equator Slice (E) would rotate on the axis pointing straight up ( 0, 1, 0 )
    if( this.axis === undefined || this.axis.lengthSq() === 0 ){
    //  Addressing orthagonal strips of Cubelets is more easily done by
    //  cube notation for the X and Y axes.
    this.down = new ThreeTwist.Group(
    this.middle = new ThreeTwist.Group(
    //  then it is a Face -- a special kind of Slice.
      this.cross   = new ThreeTwist.Group( this.center, this.hasType( 'edge' ));
    //  and this is why a Slice's "origin" is NOT the same as
    this.edges = new ThreeTwist.Group( this.hasType( 'edge' ));
    //  I'm still debating whether this should be Sticker-related
    //  Writing the solver should clarify this further...
    //  And finally for the hell of it let's try diagonals via
    this.dexter = new ThreeTwist.Group(//  From top-left to bottom-right.
  //  This can be used to partially of fully rotate a slice.
  set rotation( radians ){
    if( this.ableToHideInternalFaces && this.cube.isFlagged( 'showingIntroverts' ) !== 0 && this.cube.hideInvisibleFaces ){
      var partialRotation = radians % ( Math.PI * 0.5 ) !== 0;
      this.invertedAxis.copy( this.axis ).negate();
           this.neighbour.showIntroverts( this.invertedAxis, true );
           this.cube.showIntroverts( this.invertedAxis, true );
          this.hideIntroverts( null, true );
           this.neighbour.hideIntroverts( null, true );
           this.cube.hideIntroverts( null, true );
    //  Define a delta rotation matrix from the axis and angle
    this.matrix.makeRotationAxis( this.axis, radians );
    this.axis.rotation = radians;
    //  Iterate over the cubelets and update their relative matrices
    var l = this.indices.length,
    // TODO: this could be written as a map lookup
  //  cube.slices.front.isSolved( 'front' )
  //  cube.slices.front.up.isSolved( 'up' )
  isSolved: function( face ){
        l = this.indices.length,
        if( faceColors[ color ] === undefined ){
      console.warn( 'A face [String or ThreeTwist.Controls] argument must be specified when using ThreeTwist.Group.isSolved().' );

### Usages of string 'd' in file './src/scripts/solvers.js':
  Our Cube has its own animation loop conveniently called Cube.loop().
  window.solver.consider( cube ). This means when you create your own
  Solver instance you have to set window.solver equal to your instance.
  Solver.consider() will do some very basic checking and if all's well
  you need to write yourself.
  Your logic() should return false is the cube is solved or if something's
  gone horribly wrong. This will set Cube.isSolving = false and stop the
  solver from being called within the Cube's animation loop.
  Your logic() should return true if an incremental improvement has been
  made and the logic() should be run again in the next loop; For example,
  @author Mark Lundin - http://www.mark-lundin.com
  //  When you create your own Solver this is the only function you need to build yourself.
  //  Having said that, it will probably be the most intense function like ... ever!
//  This is the method called within Cube.loop() when Cube.isSolving === true.
//  It will call Solver.logic() which is the function you need to fill in.
ThreeTwist.Solver.prototype.consider = function( cube ){
  //  Was our solver passed a valid Cube?
  //  Kind of important, eh?
  if( cube === undefined ){
    console.warn( 'A cube [Cube] argument must be specified for Solver.consider().' );
    console.warn( 'The cube argument provided is not a valid Cube.' );
  //  If we're solving we should really make certain we aren't shuffling!
  //  If the cube is already solved then our job is done before it started.
  //  If not, we need to try solving it using our current solve method.
  if( cube.isSolved() ){
    ThreeTwist.Solver.prototype.explain( 'I’ve found that the cube is already solved.' );
//  We should always hit at what the Solver wants to do next
//  so we can hault auto-solving and give the user a chance to
    'background-color: #EEE; color: #333', ''
//  If hinting is text displayed *before* a move is made
//  then explaining is text displayed *after* a move is made.

### Usages of string 'd' in file './src/scripts/twists.js':
  Why have twist validation code in multiple places when we can create a
  @author Mark Lundin - http://www.mark-lundin.com
ThreeTwist.Twist = function( command, degrees ){
  if( command ) {
    this.set( command, degrees );
ThreeTwist.Twist.prototype.set = function( command, degrees ){
  //  What group of Cubelets do we intend to twist?
    M: 'Middle slice',
    S: 'Standing slice',
  }[ command.toUpperCase() ];
  //  If we've received a valid twist group to operate on
  //  then we can proceed. Otherwise return false!
  if( group !== undefined ){
    //  If our degrees of rotation are negative
    //  then we need to invert the twist direction
    //  and take the absolute value of the degrees.
    //  Remember, it's ok to have degrees === undefined
    //  which will peg to the nearest degrees % 90 === 0.
    if( degrees !== undefined && degrees < 0 ){
      command = command.invert();
      degrees = degrees.absolute();
    //  Now let's note the absolute direction of the rotation
    //  as both a number and in English.
    if( command === command.toUpperCase() ){
    else if( command === command.toLowerCase() ){
    //  Finally we're ready to package up all the relevant information
    this.command   = command; //  Twist command;
    this.degrees   = degrees; //  Relative degrees (undefined is ok!);
    this.vector    = vector;  //  Absolute degree polarity;
    this.wise      = wise;    //  Absolute clock direction in English;
    //  I mean... imagine call this constructor if it tried to call itself!
      return new ThreeTwist.Twist( command.invert(), degrees );
  return this.command === twist.command && this.degrees === twist.degrees;
  this.command   = twist.command; //  Twist command;
  this.degrees   = twist.degrees; //  Relative degrees (undefined is ok!);
  this.vector    = twist.vector;  //  Absolute degree polarity;
  this.wise      = twist.wise;    //  Absolute clock direction in English;
ThreeTwist.Twist.validate = function(){
  element, i, lookAhead,
  pattern, matches, match, m, head, foot;
      lookAhead = elements[ i + 1 ];
      lookAhead = undefined;
      //  AWESOME. Nothing to do here.
        if( typeof lookAhead === 'number' ){
           elements[ i ] = new ThreeTwist.Twist( element, lookAhead );
        //  cube.twist( 'UdrLf' )
        //  cube.twist( 'Udr10Lf-30b' )
        pattern = /(-?\d+|[XLMRYUEDZFSB])/gi;
            head    = matches.slice( 0, m );
            matches = head.concat( match, foot );
        head = elements.slice( 0, i );
        elements = head.concat( matches, foot );
        i --;//  Send it through the loop again to avoid duplicating logic.
      i --;//  Send it through the loop again to avoid duplicating logic.;
      head = elements.slice( 0, i );
      elements = head.concat( element, foot );
      i --;//  Send it through the loop again to avoid duplicating logic.;
      //  Whatever this element is, we don't recognize it.
      //  (Could be a Number that we're discarding on purpose.)
      i --;//  Send it through the loop again to avoid duplicating logic.;

### Usages of string 'd' in file './src/scripts/utils/Array.js':
ThreeTwist.extend( Array.prototype, {
  distanceTo : function( target ){
  middle : function(){
    return this[ Math.round(( this.length - 1 ) / 2 ) ];
  rand : function(){
    return this[ Math.floor( Math.random() * this.length )];
  random : function(){//  Convenience here. Exactly the same as .rand().
    return this[ Math.floor( Math.random() * this.length )];
      j = Math.floor( Math.random() * ( i + 1 ));
  toText : function( depth ){
    var i, indent, text;
    depth = _.cascade( depth, 0 );
    indent = '\n' + '\t'.multiply( depth );
        text += indent + this[ i ].toText( depth + 1 );
        text += indent + this[ i ];

### Usages of string 'd' in file './src/scripts/utils/Number.js':
ThreeTwist.extend( Number.prototype, {
  add : function(){
  degreesToDirection : function(){
    var d = this % 360,
    directions = [ 'N', 'NNE', 'NE', 'NEE', 'E', 'SEE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'SWW', 'W', 'NWW', 'NW', 'NNW', 'N' ];
    return directions[ this.scale( 0, 360, 0, directions.length - 1 ).round() ];
  degreesToRadians : function(){
  divide : function(){
    return Math.log( this ) / ( base === undefined ? 1 : Math.log( base ));
    // is this more pragmatic? ---> return ( '' + this.round() ).length;
  modulo : function( n ){
  radiansToDegrees : function(){
  rand : function( n ){
    if( n !== undefined ){
      return min + Math.floor( Math.random() * ( max - min ));
    return Math.floor( Math.random() * this );
  random : function( n ){
    if( n !== undefined ){
      return min + Math.random() * ( max - min );
    return Math.random() * this;
  remainder : function( n ){
  round : function( decimals ){
    decimals = decimals || 0;
    n *= Math.pow( 10, decimals );
    n  = Math.round( n );
    n /= Math.pow( 10, decimals );
  roundDown : function(){
  roundUp : function(){
  toPaddedString : function( padding ){
    return ( '0000000000000' + String( this )).slice( -padding );
  toSignedString : function(){
    var stringed = '' + this;
      stringed = '+' + stringed;
    return stringed;

### Usages of string 'd' in file './src/scripts/utils/String.js':
ThreeTwist.extend( String.prototype, {
    thisLeftLength  = Math.round( this.length / 2 ),
    containerLeftLength  = Math.round( n / 2 ),
    padLeftLength  = containerLeftLength  - thisLeftLength,
    padRightLength = containerRightLength - thisRightLength,
    centered = this;
    if( padLeftLength > 0 ){
      while( padLeftLength -- ) {
        centered = ' ' + centered;
    else if( padLeftLength < 0 ){
      centered = centered.substr( padLeftLength * -1 );
    if( padRightLength > 0 ){
      while( padRightLength -- ) {
        centered += ' ';
    else if( padRightLength < 0 ){
      centered = centered.substr( 0, centered.length + padRightLength );
    return centered;
    var justified = this;
    while( justified.length < n ) {
      justified = justified + ' ';
    return justified;
    var justified = this;
    while( justified.length < n ) {
      justified = ' ' + justified;
    return justified;
    n = _.cascade( n, 2 );
      entities += '&#' + this.charCodeAt( i ) + ';';
    joined = split[ 0 ],
      joined += split[ i ].capitalize();
    return joined;
  directionToDegrees : function(){
    directions = [ 'N', 'NNE', 'NE', 'NEE', 'E', 'SEE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'SWW', 'W', 'NWW', 'NW', 'NNW', 'N' ],
    i = directions.indexOf( this.toUpperCase() );
    return i >= 0 ? i.scale( 0, directions.length - 1, 0, 360 ) : Number.NaN;
  toUnderscoreCase : function(){
    var underscored = this.replace( /[A-Z]+/g, function( $0 ){
    if( underscored.charAt( 0 ) === '_' ) {
      underscored = underscored.substr( 1 );
    return underscored.toLowerCase();
  toUnicode : function(){
    var i, u, unicode = '';
      u = this.charCodeAt( i ).toString( 16 ).toUpperCase();
      unicode += '\\u' + u;
    return unicode;

### Usages of string 'd' in file './src/scripts/utils/utils.js':
  cascade: function(){
      if( args[ i ] !== undefined ) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

